<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPG Survivors Web</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Silkscreen', sans-serif;
            color: white;
            overflow: hidden;
        }

        canvas {
            background-color: #1e1e1e;
            display: block;
            border: 2px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // Aguarda o carregamento completo da página para iniciar o jogo
        window.onload = () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            // ---------------- CONFIGURAÇÕES GERAIS ----------------
            const SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600;
            canvas.width = SCREEN_WIDTH;
            canvas.height = SCREEN_HEIGHT;
            const WHITE = "#FFFFFF";
            const BLACK = "#000000";
            const DARK_BG = "#1e1e1e";
            const PLAYER_COLOR = "#3296FF";
            const HP_COLOR = "#B41414";
            const MANA_COLOR = "#1450B4";
            const XP_COLOR = "#FFD700";
            const GOLD_COLOR = "#FFDF00";
            const BAR_BG_COLOR = "#323232";
            const TITLE_COLOR = "#FFDC64";
            const COOLDOWN_COLOR = "rgba(0, 0, 0, 0.7)";
            const DAMAGE_COLOR = "#FF5050";
            const UI_BG_COLOR = "rgba(10, 10, 20, 0.86)";
            const SOUL_COLOR = "#A020F0";

            // CORES DAS CARTAS
            const ATTACK_CARD_COLOR = "#8C4646";
            const ATTACK_BORDER_COLOR = "#DC8C8C";
            const SUPPORT_CARD_COLOR = "#46508C";
            const SUPPORT_BORDER_COLOR = "#8C96DC";
            const ABILITY_CARD_COLOR = "#8C7846";
            const ABILITY_BORDER_COLOR = "#FFD700";
            const UNIQUE_CARD_COLOR = "#6E468C";
            const UNIQUE_BORDER_COLOR = "#B48CDC";
            
            // --- CONFIGURAÇÕES DO MAPA ---
            const TILE_SIZE = 32;
            const MAP_WIDTH_TILES = 80;
            const MAP_HEIGHT_TILES = 60;
            const SOLID_TILES = new Set([1, 2, 3, 8]); // Adicionado 8 (topo da parede) como sólido

            // ---------------- CONFIGURAÇÕES DE TECLAS ----------------
            const keybinds = {
                UP: 'KeyW',
                DOWN: 'KeyS',
                LEFT: 'KeyA',
                RIGHT: 'KeyD',
                INTERACT: 'KeyE',
                ABILITY1: 'Digit1',
                ABILITY2: 'Digit2',
                ABILITY3: 'Digit3',
                ABILITY4: 'Digit4',
                ABILITY5: 'Digit5',
                SHOW_INVENTORY: 'Tab',
                PAUSE: 'Escape',
            };
            const keybindLabels = {
                UP: 'Cima', DOWN: 'Baixo', LEFT: 'Esquerda', RIGHT: 'Direita',
                INTERACT: 'Interagir', ABILITY1: 'Habilidade 1', ABILITY2: 'Habilidade 2',
                ABILITY3: 'Habilidade 3', ABILITY4: 'Habilidade 4', ABILITY5: 'Habilidade 5',
                SHOW_INVENTORY: 'Abrir Inventário', PAUSE: 'Pausar',
            };

            // ---------------- FUNÇÕES DE GERAÇÃO DE SPRITES ----------------
            function generateSpriteSheet(drawFunction, width = 128, height = 32) {
                const spriteCanvas = document.createElement('canvas');
                spriteCanvas.width = width;
                spriteCanvas.height = height;
                const spriteCtx = spriteCanvas.getContext('2d');
                drawFunction(spriteCtx);
                const image = new Image();
                image.src = spriteCanvas.toDataURL();
                return image;
            }

            const playerSpriteSheet = generateSpriteSheet(spriteCtx => {
                const colors = { 
                    robe: '#4c3b71', robe_dark: '#2e2446', robe_light: '#6c5b91',
                    hood: '#3a2b51', hood_dark: '#1a0b21', hood_light: '#5a4b71',
                    cape: '#8b008b', cape_dark: '#6b006b', cape_light: '#ab00ab',
                    skin: '#fdbcb4', skin_dark: '#e6a89c', skin_shadow: '#d4968a',
                    staff: '#654321', staff_dark: '#432109', staff_light: '#876543',
                    crystal: '#ff00ff', crystal_dark: '#cc00cc', crystal_bright: '#ff44ff',
                    eyes: '#4a4a4a', hair: '#8b4513', hair_dark: '#654321',
                    beard: '#8b4513', beard_dark: '#654321', beard_light: '#a0522d',
                    magic: '#00ffff', magic_dark: '#00cccc', magic_bright: '#44ffff',
                    belt: '#8b4513', belt_dark: '#654321', belt_light: '#a0522d'
                };
                
                // Função para desenhar corpo do mago em perspectiva 2.5D
                function drawMageBody2_5D(ctx, x, y, width, height, color, darkColor, lightColor) {
                    // Corpo principal (perspectiva 3/4)
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4, y);
                    ctx.lineTo(x + width, y + height/4);
                    ctx.lineTo(x + width, y + height);
                    ctx.lineTo(x + width/4, y + height);
                    ctx.lineTo(x, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Corpo principal
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4 + 1, y + 1);
                    ctx.lineTo(x + width - 1, y + height/4 + 1);
                    ctx.lineTo(x + width - 1, y + height - 1);
                    ctx.lineTo(x + width/4 + 1, y + height - 1);
                    ctx.lineTo(x + 1, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Detalhes de luz
                    ctx.fillStyle = lightColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4 + 2, y + 2);
                    ctx.lineTo(x + width - 2, y + height/4 + 2);
                    ctx.lineTo(x + width - 2, y + height/2);
                    ctx.lineTo(x + width/4 + 2, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Dobras da túnica
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + width/4 + 3, y + 3, 1, height - 6);
                    ctx.fillRect(x + width - 4, y + 3, 1, height - 6);
                }
                
                // Função para desenhar cabeça do mago em perspectiva 2.5D
                function drawMageHead2_5D(ctx, x, y, size, skinColor, darkColor) {
                    // Cabeça (oval em perspectiva)
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.ellipse(x + size/2, y + size/2, size/2, size/2.5, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = skinColor;
                    ctx.beginPath();
                    ctx.ellipse(x + size/2, y + size/2, size/2 - 1, size/2.5 - 1, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Olhos sábios
                    ctx.fillStyle = colors.eyes;
                    ctx.fillRect(x + size/2 - 3, y + size/2 - 2, 2, 2);
                    ctx.fillRect(x + size/2 + 1, y + size/2 - 2, 2, 2);
                    
                    // Barba
                    ctx.fillStyle = colors.beard_dark;
                    ctx.beginPath();
                    ctx.moveTo(x + size/2 - 2, y + size/2 + 2);
                    ctx.lineTo(x + size/2 + 2, y + size/2 + 2);
                    ctx.lineTo(x + size/2 + 1, y + size/2 + 4);
                    ctx.lineTo(x + size/2 - 1, y + size/2 + 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = colors.beard;
                    ctx.beginPath();
                    ctx.moveTo(x + size/2 - 1, y + size/2 + 3);
                    ctx.lineTo(x + size/2 + 1, y + size/2 + 3);
                    ctx.lineTo(x + size/2, y + size/2 + 3);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Função para desenhar capuz do mago
                function drawMageHood2_5D(ctx, x, y, size, hoodColor, darkColor, lightColor) {
                    // Capuz (perspectiva 3/4)
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x + size/4, y);
                    ctx.lineTo(x + size, y + size/4);
                    ctx.lineTo(x + size, y + size);
                    ctx.lineTo(x + size/4, y + size);
                    ctx.lineTo(x, y + size/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Capuz principal
                    ctx.fillStyle = hoodColor;
                    ctx.beginPath();
                    ctx.moveTo(x + size/4 + 1, y + 1);
                    ctx.lineTo(x + size - 1, y + size/4 + 1);
                    ctx.lineTo(x + size - 1, y + size - 1);
                    ctx.lineTo(x + size/4 + 1, y + size - 1);
                    ctx.lineTo(x + 1, y + size/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Detalhes do capuz
                    ctx.fillStyle = lightColor;
                    ctx.beginPath();
                    ctx.moveTo(x + size/4 + 2, y + 2);
                    ctx.lineTo(x + size - 2, y + size/4 + 2);
                    ctx.lineTo(x + size - 2, y + size/2);
                    ctx.lineTo(x + size/4 + 2, y + size/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Ponta do capuz
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + size/2 - 1, y + size - 2, 2, 2);
                    ctx.fillStyle = hoodColor;
                    ctx.fillRect(x + size/2, y + size - 1, 1, 1);
                }
                
                // Função para desenhar cajado do mago
                function drawMageStaff2_5D(ctx, x, y, length, staffColor, darkColor, lightColor) {
                    // Cajado
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, 2, length);
                    ctx.fillStyle = staffColor;
                    ctx.fillRect(x + 1, y + 1, 1, length - 2);
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 1, y + 2, 1, 2);
                    
                    // Cristal mágico
                    ctx.fillStyle = colors.crystal_dark;
                    ctx.fillRect(x - 1, y - 2, 4, 4);
                    ctx.fillStyle = colors.crystal;
                    ctx.fillRect(x, y - 1, 2, 2);
                    ctx.fillStyle = colors.crystal_bright;
                    ctx.fillRect(x, y, 1, 1);
                }
                
                // Frame 1 - Posição neutra (Mago)
                // Corpo principal (túnica)
                drawMageBody2_5D(spriteCtx, 8, 12, 16, 20, colors.robe, colors.robe_dark, colors.robe_light);
                
                // Cabeça
                drawMageHead2_5D(spriteCtx, 12, 4, 8, colors.skin, colors.skin_shadow);
                
                // Capuz
                drawMageHood2_5D(spriteCtx, 10, 2, 12, colors.hood, colors.hood_dark, colors.hood_light);
                
                // Braço direito (mais próximo) - segurando cajado
                spriteCtx.fillStyle = colors.skin_shadow;
                spriteCtx.fillRect(20, 14, 3, 8);
                spriteCtx.fillStyle = colors.skin;
                spriteCtx.fillRect(21, 15, 1, 6);
                
                // Braço esquerdo (mais distante)
                spriteCtx.fillStyle = colors.skin_shadow;
                spriteCtx.fillRect(4, 16, 2, 6);
                spriteCtx.fillStyle = colors.skin;
                spriteCtx.fillRect(5, 17, 1, 4);
                
                // Pernas (botas)
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(10, 28, 4, 8);
                spriteCtx.fillRect(18, 28, 4, 8);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(11, 29, 2, 6);
                spriteCtx.fillRect(19, 29, 2, 6);
                
                // Cinto
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(8, 20, 16, 2);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(9, 21, 14, 1);
                spriteCtx.fillStyle = colors.belt_light;
                spriteCtx.fillRect(10, 21, 12, 1);
                
                // Cajado
                drawMageStaff2_5D(spriteCtx, 24, 8, 16, colors.staff, colors.staff_dark, colors.staff_light);
                
                // Capa
                spriteCtx.fillStyle = colors.cape_dark;
                spriteCtx.beginPath();
                spriteCtx.moveTo(6, 8);
                spriteCtx.lineTo(26, 8);
                spriteCtx.lineTo(24, 32);
                spriteCtx.lineTo(8, 32);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                spriteCtx.fillStyle = colors.cape;
                spriteCtx.beginPath();
                spriteCtx.moveTo(7, 9);
                spriteCtx.lineTo(25, 9);
                spriteCtx.lineTo(23, 31);
                spriteCtx.lineTo(9, 31);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                // Efeitos mágicos
                spriteCtx.fillStyle = colors.magic;
                spriteCtx.fillRect(26, 6, 1, 1);
                spriteCtx.fillRect(28, 8, 1, 1);
                spriteCtx.fillRect(25, 10, 1, 1);
                
                // Frame 2 - Passo direito (Mago)
                spriteCtx.translate(32, 0);
                drawMageBody2_5D(spriteCtx, 8, 13, 16, 19, colors.robe, colors.robe_dark, colors.robe_light);
                
                // Cabeça com movimento sutil
                drawMageHead2_5D(spriteCtx, 12, 5, 8, colors.skin, colors.skin_shadow);
                
                // Capuz
                drawMageHood2_5D(spriteCtx, 10, 3, 12, colors.hood, colors.hood_dark, colors.hood_light);
                
                // Braços com movimento
                spriteCtx.fillStyle = colors.skin_shadow;
                spriteCtx.fillRect(21, 15, 3, 8);
                spriteCtx.fillRect(3, 17, 2, 6);
                spriteCtx.fillStyle = colors.skin;
                spriteCtx.fillRect(22, 16, 1, 6);
                spriteCtx.fillRect(4, 18, 1, 4);
                
                // Pernas com movimento
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(9, 29, 4, 8);
                spriteCtx.fillRect(19, 27, 4, 8);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(10, 30, 2, 6);
                spriteCtx.fillRect(20, 28, 2, 6);
                
                // Cinto
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(8, 21, 16, 2);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(9, 22, 14, 1);
                
                // Cajado com movimento
                drawMageStaff2_5D(spriteCtx, 25, 9, 15, colors.staff, colors.staff_dark, colors.staff_light);
                
                // Capa com movimento
                spriteCtx.fillStyle = colors.cape_dark;
                spriteCtx.beginPath();
                spriteCtx.moveTo(6, 9);
                spriteCtx.lineTo(26, 9);
                spriteCtx.lineTo(24, 31);
                spriteCtx.lineTo(8, 31);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                spriteCtx.fillStyle = colors.cape;
                spriteCtx.beginPath();
                spriteCtx.moveTo(7, 10);
                spriteCtx.lineTo(25, 10);
                spriteCtx.lineTo(23, 30);
                spriteCtx.lineTo(9, 30);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                // Efeitos mágicos
                spriteCtx.fillStyle = colors.magic;
                spriteCtx.fillRect(27, 7, 1, 1);
                spriteCtx.fillRect(29, 9, 1, 1);
                spriteCtx.fillRect(26, 11, 1, 1);
                
                // Frame 3 - Posição neutra (espelhada) (Mago)
                spriteCtx.translate(32, 0);
                drawMageBody2_5D(spriteCtx, 8, 12, 16, 20, colors.robe, colors.robe_dark, colors.robe_light);
                
                // Cabeça
                drawMageHead2_5D(spriteCtx, 12, 4, 8, colors.skin, colors.skin_shadow);
                
                // Capuz
                drawMageHood2_5D(spriteCtx, 10, 2, 12, colors.hood, colors.hood_dark, colors.hood_light);
                
                // Braços
                spriteCtx.fillStyle = colors.skin_shadow;
                spriteCtx.fillRect(20, 14, 3, 8);
                spriteCtx.fillRect(4, 16, 2, 6);
                spriteCtx.fillStyle = colors.skin;
                spriteCtx.fillRect(21, 15, 1, 6);
                spriteCtx.fillRect(5, 17, 1, 4);
                
                // Pernas
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(10, 28, 4, 8);
                spriteCtx.fillRect(18, 28, 4, 8);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(11, 29, 2, 6);
                spriteCtx.fillRect(19, 29, 2, 6);
                
                // Cinto
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(8, 20, 16, 2);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(9, 21, 14, 1);
                spriteCtx.fillStyle = colors.belt_light;
                spriteCtx.fillRect(10, 21, 12, 1);
                
                // Cajado
                drawMageStaff2_5D(spriteCtx, 24, 8, 16, colors.staff, colors.staff_dark, colors.staff_light);
                
                // Capa
                spriteCtx.fillStyle = colors.cape_dark;
                spriteCtx.beginPath();
                spriteCtx.moveTo(6, 8);
                spriteCtx.lineTo(26, 8);
                spriteCtx.lineTo(24, 32);
                spriteCtx.lineTo(8, 32);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                spriteCtx.fillStyle = colors.cape;
                spriteCtx.beginPath();
                spriteCtx.moveTo(7, 9);
                spriteCtx.lineTo(25, 9);
                spriteCtx.lineTo(23, 31);
                spriteCtx.lineTo(9, 31);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                // Efeitos mágicos
                spriteCtx.fillStyle = colors.magic;
                spriteCtx.fillRect(26, 6, 1, 1);
                spriteCtx.fillRect(28, 8, 1, 1);
                spriteCtx.fillRect(25, 10, 1, 1);
                
                // Frame 4 - Passo esquerdo (Mago)
                spriteCtx.translate(32, 0);
                drawMageBody2_5D(spriteCtx, 8, 14, 16, 18, colors.robe, colors.robe_dark, colors.robe_light);
                
                // Cabeça com movimento sutil
                drawMageHead2_5D(spriteCtx, 12, 6, 8, colors.skin, colors.skin_shadow);
                
                // Capuz
                drawMageHood2_5D(spriteCtx, 10, 4, 12, colors.hood, colors.hood_dark, colors.hood_light);
                
                // Braços com movimento
                spriteCtx.fillStyle = colors.skin_shadow;
                spriteCtx.fillRect(19, 16, 3, 8);
                spriteCtx.fillRect(5, 18, 2, 6);
                spriteCtx.fillStyle = colors.skin;
                spriteCtx.fillRect(20, 17, 1, 6);
                spriteCtx.fillRect(6, 19, 1, 4);
                
                // Pernas com movimento
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(11, 30, 4, 8);
                spriteCtx.fillRect(17, 28, 4, 8);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(12, 31, 2, 6);
                spriteCtx.fillRect(18, 29, 2, 6);
                
                // Cinto
                spriteCtx.fillStyle = colors.belt_dark;
                spriteCtx.fillRect(8, 22, 16, 2);
                spriteCtx.fillStyle = colors.belt;
                spriteCtx.fillRect(9, 23, 14, 1);
                
                // Cajado com movimento
                drawMageStaff2_5D(spriteCtx, 23, 10, 14, colors.staff, colors.staff_dark, colors.staff_light);
                
                // Capa com movimento
                spriteCtx.fillStyle = colors.cape_dark;
                spriteCtx.beginPath();
                spriteCtx.moveTo(6, 10);
                spriteCtx.lineTo(26, 10);
                spriteCtx.lineTo(24, 30);
                spriteCtx.lineTo(8, 30);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                spriteCtx.fillStyle = colors.cape;
                spriteCtx.beginPath();
                spriteCtx.moveTo(7, 11);
                spriteCtx.lineTo(25, 11);
                spriteCtx.lineTo(23, 29);
                spriteCtx.lineTo(9, 29);
                spriteCtx.closePath();
                spriteCtx.fill();
                
                // Efeitos mágicos
                spriteCtx.fillStyle = colors.magic;
                spriteCtx.fillRect(25, 8, 1, 1);
                spriteCtx.fillRect(27, 10, 1, 1);
                spriteCtx.fillRect(24, 12, 1, 1);
            }, 128, 32);

            const baseEnemySpriteSheet = generateSpriteSheet(spriteCtx => { // Goblin
                const colors = { 
                    skin: '#3a7d44', skin_dark: '#2a5c31', skin_light: '#4a8d54',
                    loincloth: '#6b4226', loincloth_dark: '#4a2f1a', loincloth_light: '#8b5a3a',
                    eyes: '#ff0000', eyes_glow: '#ff4444', teeth: '#ffff00',
                    claws: '#8b4513', claws_dark: '#654321', nose: '#2a5c31',
                    hair: '#1a4d1a', hair_dark: '#0d2e0d', weapon: '#654321'
                };
                
                // Função para desenhar corpo goblin em perspectiva 2.5D
                function drawGoblinBody2_5D(ctx, x, y, width, height, skinColor, darkColor, lightColor) {
                    // Corpo principal (perspectiva 3/4)
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4, y);
                    ctx.lineTo(x + width, y + height/4);
                    ctx.lineTo(x + width, y + height);
                    ctx.lineTo(x + width/4, y + height);
                    ctx.lineTo(x, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Corpo principal
                    ctx.fillStyle = skinColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4 + 1, y + 1);
                    ctx.lineTo(x + width - 1, y + height/4 + 1);
                    ctx.lineTo(x + width - 1, y + height - 1);
                    ctx.lineTo(x + width/4 + 1, y + height - 1);
                    ctx.lineTo(x + 1, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Detalhes musculares
                    ctx.fillStyle = lightColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4 + 2, y + 2);
                    ctx.lineTo(x + width - 2, y + height/4 + 2);
                    ctx.lineTo(x + width - 2, y + height/2);
                    ctx.lineTo(x + width/4 + 2, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Cicatrizes
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + width/4 + 4, y + 4, 2, 1);
                    ctx.fillRect(x + width - 6, y + 6, 2, 1);
                }
                
                // Função para desenhar cabeça goblin em perspectiva 2.5D
                function drawGoblinHead2_5D(ctx, x, y, size, skinColor, darkColor) {
                    // Cabeça (oval em perspectiva)
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.ellipse(x + size/2, y + size/2, size/2, size/2.5, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = skinColor;
                    ctx.beginPath();
                    ctx.ellipse(x + size/2, y + size/2, size/2 - 1, size/2.5 - 1, 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Orelhas pontudas
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x + size/2 - 6, y + size/2 - 2);
                    ctx.lineTo(x + size/2 - 4, y + size/2 - 4);
                    ctx.lineTo(x + size/2 - 2, y + size/2 - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(x + size/2 + 2, y + size/2 - 2);
                    ctx.lineTo(x + size/2 + 4, y + size/2 - 4);
                    ctx.lineTo(x + size/2 + 6, y + size/2 - 2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Olhos brilhantes
                    ctx.fillStyle = colors.eyes_glow;
                    ctx.fillRect(x + size/2 - 4, y + size/2 - 2, 3, 2);
                    ctx.fillRect(x + size/2 + 1, y + size/2 - 2, 3, 2);
                    ctx.fillStyle = colors.eyes;
                    ctx.fillRect(x + size/2 - 3, y + size/2 - 1, 2, 1);
                    ctx.fillRect(x + size/2 + 2, y + size/2 - 1, 2, 1);
                    
                    // Nariz
                    ctx.fillStyle = colors.nose;
                    ctx.fillRect(x + size/2 - 1, y + size/2 + 1, 2, 1);
                    
                    // Boca com dentes
                    ctx.fillStyle = colors.skin_dark;
                    ctx.fillRect(x + size/2 - 2, y + size/2 + 2, 4, 1);
                    ctx.fillStyle = colors.teeth;
                    ctx.fillRect(x + size/2 - 1, y + size/2 + 1, 1, 1);
                    ctx.fillRect(x + size/2 + 1, y + size/2 + 1, 1, 1);
                }
                
                for (let i = 0; i < 4; i++) {
                    const yOff = i % 2 === 0 ? 0 : 2;
                    const walkCycle = Math.sin(i * Math.PI / 2) * 1;
                    
                    // Corpo com perspectiva 2.5D
                    drawGoblinBody2_5D(spriteCtx, 6, 8 + yOff, 20, 20, colors.skin, colors.skin_dark, colors.skin_light);
                    
                    // Cabeça
                    drawGoblinHead2_5D(spriteCtx, 10, 2 + yOff, 12, colors.skin, colors.skin_shadow);
                    
                    // Cabelo
                    spriteCtx.fillStyle = colors.hair_dark;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(16, 4 + yOff, 8, 3, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    spriteCtx.fillStyle = colors.hair;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(16, 4 + yOff, 7, 2, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    // Braços
                    spriteCtx.fillStyle = colors.skin_dark;
                    spriteCtx.fillRect(22, 10 + yOff, 3, 8);
                    spriteCtx.fillRect(7, 12 + yOff, 2, 6);
                    spriteCtx.fillStyle = colors.skin;
                    spriteCtx.fillRect(23, 11 + yOff, 1, 6);
                    spriteCtx.fillRect(8, 13 + yOff, 1, 4);
                    
                    // Pernas
                    spriteCtx.fillStyle = colors.skin_dark;
                    spriteCtx.fillRect(12, 24 + yOff, 3, 8);
                    spriteCtx.fillRect(17, 24 + yOff, 3, 8);
                    spriteCtx.fillStyle = colors.skin;
                    spriteCtx.fillRect(13, 25 + yOff, 1, 6);
                    spriteCtx.fillRect(18, 25 + yOff, 1, 6);
                    
                    // Tanga
                    spriteCtx.fillStyle = colors.loincloth_dark;
                    spriteCtx.fillRect(10, 22 + yOff, 12, 4);
                    spriteCtx.fillStyle = colors.loincloth;
                    spriteCtx.fillRect(11, 23 + yOff, 10, 2);
                    spriteCtx.fillStyle = colors.loincloth_light;
                    spriteCtx.fillRect(12, 24 + yOff, 8, 1);
                    
                    // Garras
                    spriteCtx.fillStyle = colors.claws_dark;
                    spriteCtx.fillRect(24, 18 + yOff, 1, 2);
                    spriteCtx.fillRect(6, 18 + yOff, 1, 2);
                    spriteCtx.fillStyle = colors.claws;
                    spriteCtx.fillRect(24, 19 + yOff, 1, 1);
                    spriteCtx.fillRect(6, 19 + yOff, 1, 1);
                    
                    // Arma primitiva
                    spriteCtx.fillStyle = colors.weapon;
                    spriteCtx.fillRect(26, 6 + yOff, 2, 10);
                    spriteCtx.fillStyle = colors.claws_dark;
                    spriteCtx.fillRect(27, 5 + yOff, 1, 2);
                    
                    spriteCtx.translate(32, 0);
                }
            });
            
            const slimeEnemySpriteSheet = generateSpriteSheet(spriteCtx => {
                const colors = { 
                    body: '#6eeB83', body_dark: '#4a9d5a', body_light: '#8eff9f',
                    highlight: '#a7ffb9', highlight_bright: '#c7ffd9', 
                    bubble: 'rgba(255,255,255,0.4)', bubble_dark: 'rgba(255,255,255,0.2)',
                    core: '#4a7d5a', core_glow: '#6a9d7a', 
                    acid: '#8aff4a', acid_dark: '#6adf2a', acid_bright: '#aaff6a',
                    eye: '#ff4444', eye_glow: '#ff6666', pupil: '#000000'
                };
                
                // Função para desenhar slime em perspectiva 2.5D
                function drawSlime2_5D(ctx, x, y, width, height, bodyColor, darkColor, lightColor) {
                    // Corpo principal (perspectiva 3/4)
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4, y);
                    ctx.lineTo(x + width, y + height/4);
                    ctx.lineTo(x + width, y + height);
                    ctx.lineTo(x + width/4, y + height);
                    ctx.lineTo(x, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Corpo principal
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4 + 1, y + 1);
                    ctx.lineTo(x + width - 1, y + height/4 + 1);
                    ctx.lineTo(x + width - 1, y + height - 1);
                    ctx.lineTo(x + width/4 + 1, y + height - 1);
                    ctx.lineTo(x + 1, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Highlight superior
                    ctx.fillStyle = lightColor;
                    ctx.beginPath();
                    ctx.moveTo(x + width/4 + 2, y + 2);
                    ctx.lineTo(x + width - 2, y + height/4 + 2);
                    ctx.lineTo(x + width - 2, y + height/2);
                    ctx.lineTo(x + width/4 + 2, y + height/2);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Função para desenhar bolhas
                function drawBubbles(ctx, x, y, count, bubbleColor, darkColor) {
                    for (let b = 0; b < count; b++) {
                        const bubbleX = x + Math.random() * 20 + 6;
                        const bubbleY = y + Math.random() * 15 + 8;
                        const bubbleSize = Math.random() * 2 + 1;
                        
                        ctx.fillStyle = darkColor;
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.fillStyle = bubbleColor;
                        ctx.beginPath();
                        ctx.arc(bubbleX - 0.5, bubbleY - 0.5, bubbleSize - 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                for (let i = 0; i < 4; i++) {
                    const squash = Math.sin(i * Math.PI / 2) * 2;
                    const stretch = Math.cos(i * Math.PI / 2) * 1;
                    const bounce = Math.sin(i * Math.PI / 2) * 1;
                    
                    // Corpo principal com perspectiva 2.5D
                    drawSlime2_5D(spriteCtx, 4, 8 + squash, 24 + stretch, 20 - squash, 
                                colors.body, colors.body_dark, colors.body_light);
                    
                    // Núcleo interno
                    spriteCtx.fillStyle = colors.core;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(16, 16 + squash, 5, 3, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    spriteCtx.fillStyle = colors.core_glow;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(16, 15 + squash, 3, 2, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    // Olhos
                    spriteCtx.fillStyle = colors.eye_glow;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(12, 12 + squash, 2, 1.5, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(20, 12 + squash, 2, 1.5, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    spriteCtx.fillStyle = colors.eye;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(12, 12 + squash, 1.5, 1, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(20, 12 + squash, 1.5, 1, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    spriteCtx.fillStyle = colors.pupil;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(12, 12 + squash, 0.8, 0.8, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(20, 12 + squash, 0.8, 0.8, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    // Bolhas internas
                    drawBubbles(spriteCtx, 0, 0, 3, colors.bubble, colors.bubble_dark);
                    
                    // Ácido pingando
                    spriteCtx.fillStyle = colors.acid_dark;
                    spriteCtx.fillRect(14, 26 + squash, 1, 2);
                    spriteCtx.fillRect(18, 26 + squash, 1, 2);
                    spriteCtx.fillStyle = colors.acid;
                    spriteCtx.fillRect(14, 27 + squash, 1, 1);
                    spriteCtx.fillRect(18, 27 + squash, 1, 1);
                    
                    // Reflexos
                    spriteCtx.fillStyle = colors.highlight_bright;
                    spriteCtx.beginPath();
                    spriteCtx.ellipse(20, 14 + squash, 2, 1.5, 0.3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    spriteCtx.translate(32, 0);
                }
            });

            const batEnemySpriteSheet = generateSpriteSheet(spriteCtx => {
                const colors = { 
                    body: '#4B0082', body_dark: '#2d0050', body_light: '#6d00b4',
                    wing: '#5d1c9e', wing_dark: '#3d0c6e', wing_light: '#7d2cce',
                    wing_membrane: '#8b4fc7', wing_bone: '#654321',
                    eye: '#ff0000', eye_glow: '#ff4444', pupil: '#000000',
                    fangs: '#ffffff', fangs_dark: '#cccccc',
                    fur: '#2d0050', fur_dark: '#1a0030', fur_light: '#4d0080',
                    claws: '#8b4513', claws_dark: '#654321'
                };
                
                // Função para desenhar asas com detalhes
                function drawBatWing(ctx, startX, startY, endX, endY, wingColor, darkColor, lightColor, boneColor) {
                    // Membrana da asa
                    ctx.fillStyle = darkColor;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.lineTo(startX, startY + 12);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Corpo da asa
                    ctx.fillStyle = wingColor;
                    ctx.beginPath();
                    ctx.moveTo(startX + 1, startY + 1);
                    ctx.lineTo(endX - 1, endY + 1);
                    ctx.lineTo(startX + 1, startY + 11);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Estrutura óssea
                    ctx.fillStyle = boneColor;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    
                    // Detalhes da membrana
                    ctx.fillStyle = lightColor;
                    ctx.beginPath();
                    ctx.moveTo(startX + 2, startY + 2);
                    ctx.lineTo(endX - 2, endY + 2);
                    ctx.lineTo(startX + 2, startY + 10);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Função para desenhar corpo do morcego
                function drawBatBody(ctx, x, y, width, height, bodyColor, darkColor, lightColor) {
                    // Sombra do corpo
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo principal
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Detalhes de pelagem
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 2, y + 2, width - 4, 1);
                    ctx.fillRect(x + 2, y + height - 3, width - 4, 1);
                }
                
                for (let i = 0; i < 4; i++) {
                    const wingY = Math.sin(i * Math.PI / 2) * 8 + 8;
                    const wingStretch = Math.cos(i * Math.PI / 2) * 2;
                    const bodyBob = Math.sin(i * Math.PI / 2) * 1;
                    
                    // Corpo do morcego
                    drawBatBody(spriteCtx, 12, 12 + bodyBob, 8, 10, colors.body, colors.body_dark, colors.body_light);
                    
                    // Cabeça
                    spriteCtx.fillStyle = colors.body_dark;
                    spriteCtx.fillRect(13, 10 + bodyBob, 6, 4);
                    spriteCtx.fillStyle = colors.body;
                    spriteCtx.fillRect(14, 11 + bodyBob, 4, 2);
                    
                    // Olhos com brilho
                    spriteCtx.fillStyle = colors.eye_glow;
                    spriteCtx.fillRect(13, 12 + bodyBob, 3, 2);
                    spriteCtx.fillRect(17, 12 + bodyBob, 3, 2);
                    spriteCtx.fillStyle = colors.eye;
                    spriteCtx.fillRect(14, 13 + bodyBob, 2, 1);
                    spriteCtx.fillRect(18, 13 + bodyBob, 2, 1);
                    spriteCtx.fillStyle = colors.pupil;
                    spriteCtx.fillRect(14, 13 + bodyBob, 1, 1);
                    spriteCtx.fillRect(18, 13 + bodyBob, 1, 1);
                    
                    // Orelhas
                    spriteCtx.fillStyle = colors.fur_dark;
                    spriteCtx.fillRect(12, 9 + bodyBob, 2, 2);
                    spriteCtx.fillRect(18, 9 + bodyBob, 2, 2);
                    spriteCtx.fillStyle = colors.fur;
                    spriteCtx.fillRect(12, 10 + bodyBob, 1, 1);
                    spriteCtx.fillRect(18, 10 + bodyBob, 1, 1);
                    
                    // Focinho
                    spriteCtx.fillStyle = colors.fur_dark;
                    spriteCtx.fillRect(15, 8 + bodyBob, 2, 2);
                    spriteCtx.fillStyle = colors.fur;
                    spriteCtx.fillRect(15, 9 + bodyBob, 1, 1);
                    
                    // Presas
                    spriteCtx.fillStyle = colors.fangs_dark;
                    spriteCtx.fillRect(14, 7 + bodyBob, 1, 2);
                    spriteCtx.fillRect(17, 7 + bodyBob, 1, 2);
                    spriteCtx.fillStyle = colors.fangs;
                    spriteCtx.fillRect(14, 8 + bodyBob, 1, 1);
                    spriteCtx.fillRect(17, 8 + bodyBob, 1, 1);
                    
                    // Asas com movimento
                    drawBatWing(spriteCtx, 12, 14, 0, wingY, colors.wing, colors.wing_dark, colors.wing_light, colors.wing_bone);
                    drawBatWing(spriteCtx, 20, 14, 32, wingY, colors.wing, colors.wing_dark, colors.wing_light, colors.wing_bone);
                    
                    // Membrana das asas
                    spriteCtx.fillStyle = colors.wing_membrane;
                    spriteCtx.beginPath();
                    spriteCtx.moveTo(12, 16);
                    spriteCtx.lineTo(6, wingY + 2);
                    spriteCtx.lineTo(12, 24);
                    spriteCtx.closePath();
                    spriteCtx.fill();
                    
                    spriteCtx.beginPath();
                    spriteCtx.moveTo(20, 16);
                    spriteCtx.lineTo(26, wingY + 2);
                    spriteCtx.lineTo(20, 24);
                    spriteCtx.closePath();
                    spriteCtx.fill();
                    
                    // Garras
                    spriteCtx.fillStyle = colors.claws_dark;
                    spriteCtx.fillRect(10, 20 + bodyBob, 1, 2);
                    spriteCtx.fillRect(21, 20 + bodyBob, 1, 2);
                    spriteCtx.fillStyle = colors.claws;
                    spriteCtx.fillRect(10, 21 + bodyBob, 1, 1);
                    spriteCtx.fillRect(21, 21 + bodyBob, 1, 1);
                    
                    spriteCtx.translate(32, 0);
                }
            });
            
            const rangedEnemySpriteSheet = generateSpriteSheet(spriteCtx => { // Dark Mage
                const colors = { 
                    robe: '#4c3b71', robe_dark: '#2e2446', robe_light: '#6c5b91',
                    hood: '#3a2b51', hood_dark: '#1a0b21', hood_light: '#5a4b71',
                    eye: '#ff2222', eye_glow: '#ff4444', eye_pupil: '#000000',
                    hand: '#9e73ec', hand_dark: '#7a53cc', hand_light: '#ba93fc',
                    skin: '#8b7355', skin_dark: '#6b5335', skin_light: '#ab9375',
                    magic: '#ff00ff', magic_dark: '#cc00cc', magic_bright: '#ff44ff',
                    staff: '#654321', staff_dark: '#432109', staff_light: '#876543',
                    belt: '#8b4513', belt_dark: '#654321', belt_light: '#a0522d',
                    symbols: '#ffd700', symbols_dark: '#ccaa00'
                };
                
                // Função para desenhar detalhes da capa
                function drawRobeDetails(ctx, x, y, width, height, robeColor, darkColor, lightColor) {
                    // Sombra da capa
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo da capa
                    ctx.fillStyle = robeColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Dobras da capa
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + 2, y + 2, 1, height - 4);
                    ctx.fillRect(x + width - 3, y + 2, 1, height - 4);
                    
                    // Bordas brilhantes
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, 1);
                    ctx.fillRect(x + 1, y + height - 2, width - 2, 1);
                }
                
                // Função para desenhar capuz
                function drawHoodDetails(ctx, x, y, width, height, hoodColor, darkColor, lightColor) {
                    // Sombra do capuz
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo do capuz
                    ctx.fillStyle = hoodColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Detalhes do capuz
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 2, y + 2, width - 4, 1);
                    ctx.fillRect(x + 2, y + height - 3, width - 4, 1);
                    
                    // Ponta do capuz
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + width/2 - 1, y + height - 2, 2, 2);
                    ctx.fillStyle = hoodColor;
                    ctx.fillRect(x + width/2, y + height - 1, 1, 1);
                }
                
                // Função para desenhar efeitos mágicos
                function drawMagicEffects(ctx, x, y, intensity) {
                    // Partículas mágicas
                    for (let p = 0; p < 3; p++) {
                        const particleX = x + Math.sin(p * 2) * 4;
                        const particleY = y + Math.cos(p * 2) * 4;
                        const alpha = intensity * 0.6;
                        
                        ctx.fillStyle = `rgba(255, 0, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                 for (let i = 0; i < 4; i++) {
                     const yOff = i % 2 === 0 ? 0 : 1;
                    const magicIntensity = Math.sin(i * Math.PI / 2) * 0.5 + 0.5;
                    const robeSway = Math.sin(i * Math.PI / 2) * 1;
                    
                    // Corpo da capa
                    drawRobeDetails(spriteCtx, 6, 6, 20, 26, colors.robe, colors.robe_dark, colors.robe_light);
                    
                    // Capuz
                    drawHoodDetails(spriteCtx, 10, 4, 12, 12, colors.hood, colors.hood_dark, colors.hood_light);
                    
                    // Face nas sombras
                    spriteCtx.fillStyle = colors.skin_dark;
                    spriteCtx.fillRect(11, 6, 10, 8);
                    spriteCtx.fillStyle = colors.skin;
                    spriteCtx.fillRect(12, 7, 8, 6);
                    
                    // Olhos brilhantes
                    spriteCtx.fillStyle = colors.eye_glow;
                    spriteCtx.fillRect(13, 9, 3, 2);
                    spriteCtx.fillRect(17, 9, 3, 2);
                    spriteCtx.fillStyle = colors.eye;
                    spriteCtx.fillRect(14, 10, 2, 1);
                    spriteCtx.fillRect(18, 10, 2, 1);
                    spriteCtx.fillStyle = colors.eye_pupil;
                    spriteCtx.fillRect(14, 10, 1, 1);
                    spriteCtx.fillRect(18, 10, 1, 1);
                    
                    // Boca
                    spriteCtx.fillStyle = colors.skin_dark;
                    spriteCtx.fillRect(15, 12, 2, 1);
                    
                    // Mãos com energia mágica
                    spriteCtx.fillStyle = colors.hand_dark;
                    spriteCtx.beginPath();
                    spriteCtx.arc(26, 20 + yOff, 4, 0, Math.PI * 2);
                    spriteCtx.fill();
                    spriteCtx.fillStyle = colors.hand;
                    spriteCtx.beginPath();
                    spriteCtx.arc(26, 20 + yOff, 3, 0, Math.PI * 2);
                    spriteCtx.fill();
                    spriteCtx.fillStyle = colors.hand_light;
                    spriteCtx.beginPath();
                    spriteCtx.arc(26, 20 + yOff, 2, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                    // Cajado
                    spriteCtx.fillStyle = colors.staff_dark;
                    spriteCtx.fillRect(28, 8 + yOff, 2, 16);
                    spriteCtx.fillStyle = colors.staff;
                    spriteCtx.fillRect(29, 9 + yOff, 1, 14);
                    spriteCtx.fillStyle = colors.staff_light;
                    spriteCtx.fillRect(29, 10 + yOff, 1, 2);
                    
                    // Cristal do cajado
                    spriteCtx.fillStyle = colors.magic_dark;
                    spriteCtx.fillRect(27, 6 + yOff, 4, 4);
                    spriteCtx.fillStyle = colors.magic;
                    spriteCtx.fillRect(28, 7 + yOff, 2, 2);
                    spriteCtx.fillStyle = colors.magic_bright;
                    spriteCtx.fillRect(28, 7 + yOff, 1, 1);
                    
                    // Cinto
                    spriteCtx.fillStyle = colors.belt_dark;
                    spriteCtx.fillRect(8, 20 + yOff, 16, 2);
                    spriteCtx.fillStyle = colors.belt;
                    spriteCtx.fillRect(9, 21 + yOff, 14, 1);
                    spriteCtx.fillStyle = colors.belt_light;
                    spriteCtx.fillRect(10, 21 + yOff, 12, 1);
                    
                    // Símbolos mágicos na capa
                    spriteCtx.fillStyle = colors.symbols_dark;
                    spriteCtx.fillRect(10, 10 + yOff, 1, 1);
                    spriteCtx.fillRect(21, 10 + yOff, 1, 1);
                    spriteCtx.fillRect(10, 18 + yOff, 1, 1);
                    spriteCtx.fillRect(21, 18 + yOff, 1, 1);
                    spriteCtx.fillStyle = colors.symbols;
                    spriteCtx.fillRect(10, 11 + yOff, 1, 1);
                    spriteCtx.fillRect(21, 11 + yOff, 1, 1);
                    spriteCtx.fillRect(10, 19 + yOff, 1, 1);
                    spriteCtx.fillRect(21, 19 + yOff, 1, 1);
                    
                    // Efeitos mágicos
                    drawMagicEffects(spriteCtx, 26, 20 + yOff, magicIntensity);
                    
                    // Energia ao redor do cajado
                    spriteCtx.fillStyle = `rgba(255, 0, 255, ${magicIntensity * 0.3})`;
                    spriteCtx.beginPath();
                    spriteCtx.arc(29, 8 + yOff, 6, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                     spriteCtx.translate(32, 0);
                 }
            });
            
              const mimicEnemySpriteSheet = generateSpriteSheet(spriteCtx => {
                const colors = { 
                    body: '#A0522D', body_dark: '#8B4513', body_light: '#CD853F',
                    trim: '#FFD700', trim_dark: '#B8860B', trim_light: '#FFE55C',
                    eye: '#ffffff', eye_glow: '#ff4444', eye_pupil: '#000000',
                    teeth: '#ffffff', teeth_dark: '#cccccc', teeth_sharp: '#f0f0f0',
                    wood: '#8B4513', wood_dark: '#654321', wood_light: '#A0522D',
                    metal: '#C0C0C0', metal_dark: '#808080', metal_light: '#E0E0E0',
                    tongue: '#ff69b4', tongue_dark: '#ff1493', tongue_light: '#ffb6c1',
                    saliva: 'rgba(255,255,255,0.6)', saliva_dark: 'rgba(255,255,255,0.3)',
                    lock: '#654321', lock_dark: '#432109', lock_light: '#876543',
                    hinges: '#8B4513', hinges_dark: '#654321', hinges_light: '#A0522D'
                };
                
                // Função para desenhar detalhes da madeira
                function drawWoodDetails(ctx, x, y, width, height, woodColor, darkColor, lightColor) {
                    // Base da madeira
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo da madeira
                    ctx.fillStyle = woodColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Veios da madeira
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 2, y + 2, width - 4, 1);
                    ctx.fillRect(x + 2, y + height - 3, width - 4, 1);
                    ctx.fillRect(x + 2, y + 2, 1, height - 4);
                    ctx.fillRect(x + width - 3, y + 2, 1, height - 4);
                    
                    // Detalhes dos veios
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + 4, y + 4, 2, 1);
                    ctx.fillRect(x + width - 6, y + 6, 2, 1);
                    ctx.fillRect(x + 6, y + 8, 2, 1);
                    ctx.fillRect(x + width - 8, y + 10, 2, 1);
                }
                
                // Função para desenhar detalhes metálicos
                function drawMetalDetails(ctx, x, y, width, height, metalColor, darkColor, lightColor) {
                    // Base metálica
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo metálico
                    ctx.fillStyle = metalColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Brilho metálico
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 2, y + 2, width - 4, 1);
                    ctx.fillRect(x + 2, y + 2, 1, height - 4);
                    
                    // Rebites
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 3, y + 3, 1, 1);
                    ctx.fillRect(x + width - 4, y + 3, 1, 1);
                    ctx.fillRect(x + 3, y + height - 4, 1, 1);
                    ctx.fillRect(x + width - 4, y + height - 4, 1, 1);
                }
                
                // Função para desenhar língua
                function drawTongue(ctx, x, y, length, tongueColor, darkColor, lightColor) {
                    // Base da língua
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, length, 2);
                    
                    // Corpo da língua
                    ctx.fillStyle = tongueColor;
                    ctx.fillRect(x, y + 1, length, 1);
                    
                    // Ponta da língua
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + length - 1, y, 1, 2);
                }
                
                for (let i = 0; i < 4; i++) {
                    const yOff = i % 2 === 0 ? 0 : 2;
                    const mouthOpen = Math.sin(i * Math.PI / 2) * 2;
                    const tongueLength = Math.sin(i * Math.PI / 2) * 3 + 2;
                    
                    // Caixa principal com detalhes de madeira
                    drawWoodDetails(spriteCtx, 2, 6, 28, 24, colors.body, colors.body_dark, colors.body_light);
                    
                    // Detalhes da caixa
                    spriteCtx.fillStyle = colors.wood_dark;
                    spriteCtx.fillRect(4, 8 + yOff, 24, 20);
                    spriteCtx.fillStyle = colors.wood;
                    spriteCtx.fillRect(5, 9 + yOff, 22, 18);
                    spriteCtx.fillStyle = colors.wood_light;
                    spriteCtx.fillRect(6, 10 + yOff, 20, 16);
                    
                    // Bordas douradas
                    spriteCtx.fillStyle = colors.trim_dark;
                    spriteCtx.fillRect(2, 8 + yOff, 28, 4);
                    spriteCtx.fillRect(2, 24 + yOff, 28, 4);
                    spriteCtx.fillRect(2, 8 + yOff, 4, 20);
                    spriteCtx.fillRect(26, 8 + yOff, 4, 20);
                    
                    spriteCtx.fillStyle = colors.trim;
                    spriteCtx.fillRect(3, 9 + yOff, 26, 2);
                    spriteCtx.fillRect(3, 25 + yOff, 26, 2);
                    spriteCtx.fillRect(3, 9 + yOff, 2, 18);
                    spriteCtx.fillRect(27, 9 + yOff, 2, 18);
                    
                    spriteCtx.fillStyle = colors.trim_light;
                    spriteCtx.fillRect(4, 10 + yOff, 24, 1);
                    spriteCtx.fillRect(4, 26 + yOff, 24, 1);
                    spriteCtx.fillRect(4, 10 + yOff, 1, 16);
                    spriteCtx.fillRect(28, 10 + yOff, 1, 16);
                    
                    // Fechadura
                    drawMetalDetails(spriteCtx, 14, 12 + yOff, 4, 6, colors.lock, colors.lock_dark, colors.lock_light);
                    
                    // Dobradiças
                    drawMetalDetails(spriteCtx, 4, 14 + yOff, 2, 4, colors.hinges, colors.hinges_dark, colors.hinges_light);
                    drawMetalDetails(spriteCtx, 26, 14 + yOff, 2, 4, colors.hinges, colors.hinges_dark, colors.hinges_light);
                    
                    // Olhos com brilho
                    spriteCtx.fillStyle = colors.eye_glow;
                    spriteCtx.fillRect(7, 11 + yOff, 6, 6);
                    spriteCtx.fillRect(19, 11 + yOff, 6, 6);
                    spriteCtx.fillStyle = colors.eye;
                    spriteCtx.fillRect(8, 12 + yOff, 4, 4);
                    spriteCtx.fillRect(20, 12 + yOff, 4, 4);
                    spriteCtx.fillStyle = colors.eye_pupil;
                    spriteCtx.fillRect(9, 13 + yOff, 2, 2);
                    spriteCtx.fillRect(21, 13 + yOff, 2, 2);
                    
                    // Boca aberta
                    spriteCtx.fillStyle = colors.body_dark;
                    spriteCtx.fillRect(8, 20 + yOff + mouthOpen, 16, 4 + mouthOpen);
                    spriteCtx.fillStyle = colors.tongue_dark;
                    spriteCtx.fillRect(10, 22 + yOff + mouthOpen, 12, 2);
                    
                    // Língua
                    drawTongue(spriteCtx, 10, 22 + yOff + mouthOpen, tongueLength, colors.tongue, colors.tongue_dark, colors.tongue_light);
                    
                    // Dentes afiados
                    spriteCtx.fillStyle = colors.teeth_dark;
                    for(let t = 0; t < 4; t++) {
                        spriteCtx.fillRect(8 + t * 4, 20 + yOff + mouthOpen, 2, 3);
                    }
                    spriteCtx.fillStyle = colors.teeth;
                    for(let t = 0; t < 4; t++) {
                        spriteCtx.fillRect(9 + t * 4, 21 + yOff + mouthOpen, 1, 2);
                    }
                    spriteCtx.fillStyle = colors.teeth_sharp;
                    for(let t = 0; t < 4; t++) {
                        spriteCtx.fillRect(9 + t * 4, 20 + yOff + mouthOpen, 1, 1);
                    }
                    
                    // Saliva pingando
                    spriteCtx.fillStyle = colors.saliva_dark;
                    spriteCtx.fillRect(12, 24 + yOff + mouthOpen, 1, 2);
                    spriteCtx.fillRect(19, 24 + yOff + mouthOpen, 1, 2);
                    spriteCtx.fillStyle = colors.saliva;
                    spriteCtx.fillRect(12, 25 + yOff + mouthOpen, 1, 1);
                    spriteCtx.fillRect(19, 25 + yOff + mouthOpen, 1, 1);
                    
                    // Reflexos na madeira
                    spriteCtx.fillStyle = colors.wood_light;
                    spriteCtx.fillRect(6, 10 + yOff, 2, 1);
                    spriteCtx.fillRect(24, 12 + yOff, 2, 1);
                    spriteCtx.fillRect(8, 16 + yOff, 2, 1);
                    spriteCtx.fillRect(22, 18 + yOff, 2, 1);
                    
                    spriteCtx.translate(32, 0);
                }
            });
            
            const bossEnemySpriteSheet = generateSpriteSheet(spriteCtx => { // Magma Golem
                const colors = { 
                    stone: '#444', stone_dark: '#222', stone_light: '#666',
                    magma: '#ff6600', magma_dark: '#cc4400', magma_bright: '#ffcc00',
                    magma_core: '#ffaa00', magma_glow: '#ffdd44', magma_flow: '#ff8800',
                    cracks: '#333', cracks_glow: '#ff4400', cracks_bright: '#ff6600',
                    eyes: '#ff0000', eyes_glow: '#ff4444', eyes_pupil: '#000000',
                    lava_drops: '#ff4400', lava_drops_dark: '#cc2200',
                    rock_details: '#555', rock_details_dark: '#333', rock_details_light: '#777',
                    steam: 'rgba(255,255,255,0.3)', steam_dark: 'rgba(255,255,255,0.1)',
                    embers: '#ff8800', embers_bright: '#ffaa00'
                };
                
                // Função para desenhar detalhes da pedra
                function drawStoneDetails(ctx, x, y, width, height, stoneColor, darkColor, lightColor) {
                    // Base da pedra
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo da pedra
                    ctx.fillStyle = stoneColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Detalhes rochosos
                    ctx.fillStyle = lightColor;
                    ctx.fillRect(x + 2, y + 2, width - 4, 1);
                    ctx.fillRect(x + 2, y + height - 3, width - 4, 1);
                    ctx.fillRect(x + 2, y + 2, 1, height - 4);
                    ctx.fillRect(x + width - 3, y + 2, 1, height - 4);
                    
                    // Textura rochosa
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x + 4, y + 4, 2, 1);
                    ctx.fillRect(x + width - 6, y + 6, 2, 1);
                    ctx.fillRect(x + 6, y + 8, 2, 1);
                    ctx.fillRect(x + width - 8, y + 10, 2, 1);
                }
                
                // Função para desenhar magma com fluxo
                function drawMagmaFlow(ctx, x, y, width, height, magmaColor, darkColor, brightColor, glowColor) {
                    // Base do magma
                    ctx.fillStyle = darkColor;
                    ctx.fillRect(x, y, width, height);
                    
                    // Corpo do magma
                    ctx.fillStyle = magmaColor;
                    ctx.fillRect(x + 1, y + 1, width - 2, height - 2);
                    
                    // Fluxo interno
                    ctx.fillStyle = brightColor;
                    ctx.fillRect(x + 2, y + 2, width - 4, height - 4);
                    
                    // Núcleo brilhante
                    ctx.fillStyle = glowColor;
                    ctx.fillRect(x + 4, y + 4, width - 8, height - 8);
                    
                    // Ondulações do magma
                    ctx.fillStyle = brightColor;
                    ctx.fillRect(x + 3, y + 3, width - 6, 1);
                    ctx.fillRect(x + 3, y + height - 4, width - 6, 1);
                    ctx.fillRect(x + 3, y + 3, 1, height - 6);
                    ctx.fillRect(x + width - 4, y + 3, 1, height - 6);
                }
                
                // Função para desenhar rachaduras
                function drawCracks(ctx, x, y, width, height, crackColor, glowColor) {
                    // Rachaduras principais
                    ctx.fillStyle = crackColor;
                    ctx.fillRect(x + 2, y + 2, 1, height - 4);
                    ctx.fillRect(x + width - 3, y + 2, 1, height - 4);
                    ctx.fillRect(x + 2, y + 2, width - 4, 1);
                    ctx.fillRect(x + 2, y + height - 3, width - 4, 1);
                    
                    // Rachaduras secundárias
                    ctx.fillRect(x + 4, y + 4, 1, 2);
                    ctx.fillRect(x + width - 5, y + 6, 1, 2);
                    ctx.fillRect(x + 6, y + 8, 1, 2);
                    ctx.fillRect(x + width - 7, y + 10, 1, 2);
                    
                    // Brilho das rachaduras
                    ctx.fillStyle = glowColor;
                    ctx.fillRect(x + 3, y + 3, 1, height - 6);
                    ctx.fillRect(x + width - 4, y + 3, 1, height - 6);
                    ctx.fillRect(x + 3, y + 3, width - 6, 1);
                    ctx.fillRect(x + 3, y + height - 4, width - 6, 1);
                }
                
                // Função para desenhar vapor
                function drawSteam(ctx, x, y, intensity) {
                    for (let s = 0; s < 3; s++) {
                        const steamX = x + Math.sin(s * 2) * 3;
                        const steamY = y + Math.cos(s * 2) * 3;
                        const alpha = intensity * 0.4;
                        
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(steamX, steamY, 1, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                for (let i = 0; i < 4; i++) {
                      const yOff = i % 2 === 0 ? 0 : 2;
                    const magmaIntensity = Math.sin(i * Math.PI / 2) * 0.5 + 0.5;
                    const steamIntensity = Math.cos(i * Math.PI / 2) * 0.5 + 0.5;
                    
                      spriteCtx.scale(0.5, 0.5); // Desenha a 64x64 e escala para 32x32
                    
                    // Corpo principal com detalhes de pedra
                    drawStoneDetails(spriteCtx, 4, 4, 56, 60, colors.stone, colors.stone_dark, colors.stone_light);
                    
                    // Braços com detalhes
                    drawStoneDetails(spriteCtx, 0, 20, 16, 32, colors.stone, colors.stone_dark, colors.stone_light);
                    drawStoneDetails(spriteCtx, 48, 20, 16, 32, colors.stone, colors.stone_dark, colors.stone_light);
                    
                    // Rachaduras com brilho
                    drawCracks(spriteCtx, 8, 8 + yOff, 48, 52, colors.cracks, colors.cracks_glow);
                    drawCracks(spriteCtx, 0, 20, 16, 32, colors.cracks, colors.cracks_glow);
                    drawCracks(spriteCtx, 48, 20, 16, 32, colors.cracks, colors.cracks_glow);
                    
                    // Núcleo de magma
                    drawMagmaFlow(spriteCtx, 20, 20 + yOff, 24, 24, colors.magma, colors.magma_dark, colors.magma_bright, colors.magma_glow);
                    
                    // Olhos brilhantes
                    spriteCtx.fillStyle = colors.eyes_glow;
                    spriteCtx.fillRect(24, 12 + yOff, 4, 4);
                    spriteCtx.fillRect(36, 12 + yOff, 4, 4);
                    spriteCtx.fillStyle = colors.eyes;
                    spriteCtx.fillRect(25, 13 + yOff, 2, 2);
                    spriteCtx.fillRect(37, 13 + yOff, 2, 2);
                    spriteCtx.fillStyle = colors.eyes_pupil;
                    spriteCtx.fillRect(25, 13 + yOff, 1, 1);
                    spriteCtx.fillRect(37, 13 + yOff, 1, 1);
                    
                    // Gotas de lava pingando
                    spriteCtx.fillStyle = colors.lava_drops_dark;
                    spriteCtx.fillRect(28, 44 + yOff, 1, 3);
                    spriteCtx.fillRect(34, 44 + yOff, 1, 3);
                    spriteCtx.fillStyle = colors.lava_drops;
                    spriteCtx.fillRect(28, 45 + yOff, 1, 2);
                    spriteCtx.fillRect(34, 45 + yOff, 1, 2);
                    
                    // Brasas
                    spriteCtx.fillStyle = colors.embers;
                    spriteCtx.fillRect(18, 18 + yOff, 1, 1);
                    spriteCtx.fillRect(45, 18 + yOff, 1, 1);
                    spriteCtx.fillRect(20, 42 + yOff, 1, 1);
                    spriteCtx.fillRect(43, 42 + yOff, 1, 1);
                    spriteCtx.fillStyle = colors.embers_bright;
                    spriteCtx.fillRect(18, 19 + yOff, 1, 1);
                    spriteCtx.fillRect(45, 19 + yOff, 1, 1);
                    
                    // Vapor
                    drawSteam(spriteCtx, 32, 8 + yOff, steamIntensity);
                    drawSteam(spriteCtx, 8, 24, steamIntensity);
                    drawSteam(spriteCtx, 56, 24, steamIntensity);
                    
                    // Energia mágica ao redor
                    spriteCtx.fillStyle = `rgba(255, 102, 0, ${magmaIntensity * 0.2})`;
                    spriteCtx.beginPath();
                    spriteCtx.arc(32, 32 + yOff, 30, 0, Math.PI * 2);
                    spriteCtx.fill();
                    
                      spriteCtx.resetTransform();
                      spriteCtx.translate(32, 0);
                }
            }, 128, 32);


            // ---------------- FUNÇÕES AUXILIARES DE UI ----------------
            function drawBar(ctx, x, y, width, height, value, maxValue, color, text = "") {
                if (maxValue <= 0) return;
                const fillWidth = Math.max(0, width * (value / maxValue));
                
                ctx.fillStyle = BAR_BG_COLOR;
                ctx.fillRect(x, y, width, height);

                if (fillWidth > 0) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, fillWidth, height);
                }

                ctx.strokeStyle = WHITE;
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
                
                if (text) {
                    ctx.font = `bold ${height - 4}px 'Silkscreen'`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = BLACK;
                    ctx.fillText(text, x + width / 2 + 1, y + height / 2 + 1);
                    ctx.fillStyle = WHITE;
                    ctx.fillText(text, x + width / 2, y + height / 2);
                }
            }

            function drawTextWrapped(ctx, text, font, color, rect) {
                const words = text.split(' ');
                let lines = [];
                let currentLine = "";
                ctx.font = font;
                ctx.fillStyle = color;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                const lineHeightMatch = font.match(/(\d+)px/);
                const lineHeight = lineHeightMatch ? parseInt(lineHeightMatch[1], 10) * 1.5 : 20;


                for (const word of words) {
                    const testLine = currentLine + word + " ";
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width < rect.width && !word.includes('\n')) {
                        currentLine = testLine;
                    } else {
                        lines.push(currentLine.trim());
                        currentLine = word + " ";
                    }
                }
                lines.push(currentLine.trim());
                
                let yOffset = 0;
                for (const line of lines) {
                    ctx.fillText(line, rect.x, rect.y + yOffset);
                    yOffset += lineHeight;
                }
            }
            
            // ---------------- INPUT HANDLER ----------------
            const keys = {};
            const mouse = { x: 0, y: 0, down: false, clicked: false };
            let game; 
            const singlePressKeys = new Set(); 

            window.addEventListener('keydown', e => { 
                e.preventDefault();
                keys[e.code] = true;
                
                if (!singlePressKeys.has(e.code)) {
                    if (game) game.handleKeyDown(e.code);
                    singlePressKeys.add(e.code);
                }
            });
            window.addEventListener('keyup', e => { 
                keys[e.code] = false;
                singlePressKeys.delete(e.code);
            });
            canvas.addEventListener('mousemove', e => {
                const rect = canvas.getBoundingClientRect();
                mouse.x = e.clientX - rect.left;
                mouse.y = e.clientY - rect.top;
            });
            canvas.addEventListener('mousedown', e => { if (e.button === 0) mouse.down = true; });
            canvas.addEventListener('mouseup', e => { 
                if (e.button === 0) {
                    mouse.down = false;
                    mouse.clicked = true; 
                }
            });

            // ---------------- CLASSE DO MAPA ----------------
            class Map {
                constructor(tilesetFilename) {
                    this.tile_size = TILE_SIZE;
                    this.tileset = new Image();
                    this.tileset.src = tilesetFilename;
                    this.tilesetReady = false;
                    this.tileset.onload = () => {
                        this.tilesetReady = true;
                        this.tiles_x = this.tileset.width / this.tile_size;
                    };
                    this.tileset.onerror = () => {
                        console.error(`Erro: Não foi possível carregar o tileset '${tilesetFilename}'. Criando um substituto.`);
                        const fallbackCanvas = document.createElement('canvas');
                        fallbackCanvas.width = TILE_SIZE * 16;
                        fallbackCanvas.height = TILE_SIZE * 16;
                        const fCtx = fallbackCanvas.getContext('2d');
                        fCtx.fillStyle = "rgba(0,0,0,0)"; fCtx.fillRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
                        
                        // Paleta de cores melhorada e expandida
                        const floorColor = "#4a4a4a";
                        const floorDetailColor = "#5a5a5a";
                        const floorDarkColor = "#3a3a3a";
                        const wallColor = "#333333";
                        const wallTopColor = "#222222";
                        const wallDetailColor = "#444444";
                        const pillarColor = "#888888";
                        const carpetColor = "#800000";
                        const carpetBorderColor = "#FFD700";
                        const altarColor = "#787878";
                        const torchColor = "#ff6600";
                        const waterColor = "#0066cc";
                        const crystalColor = "#ff00ff";

                        // Linha 0 - Tiles básicos
                        fCtx.fillStyle = floorColor; fCtx.fillRect(0, 0, TILE_SIZE, TILE_SIZE); // 0 Chão
                        fCtx.fillStyle = wallColor; fCtx.fillRect(TILE_SIZE * 1, 0, TILE_SIZE, TILE_SIZE); // 1 Parede
                        fCtx.fillStyle = pillarColor; fCtx.fillRect(TILE_SIZE * 2, 0, TILE_SIZE, TILE_SIZE); // 2 Pilar
                        fCtx.fillStyle = wallDetailColor; fCtx.fillRect(TILE_SIZE * 3, 0, TILE_SIZE, TILE_SIZE); // 3 Parede com detalhes
                        fCtx.fillStyle = carpetColor; fCtx.fillRect(TILE_SIZE * 4, 0, TILE_SIZE, TILE_SIZE); // 4 Tapete
                        fCtx.fillStyle = altarColor; fCtx.fillRect(TILE_SIZE * 5, 0, TILE_SIZE, TILE_SIZE); // 5 Altar
                        fCtx.fillStyle = floorDarkColor; fCtx.fillRect(TILE_SIZE * 6, 0, TILE_SIZE, TILE_SIZE); // 6 Ladrilho escuro
                        fCtx.fillStyle = floorDetailColor; fCtx.fillRect(TILE_SIZE * 7, 0, TILE_SIZE, TILE_SIZE); // 7 Detalhe chão
                        fCtx.fillStyle = wallTopColor; fCtx.fillRect(TILE_SIZE * 8, 0, TILE_SIZE, TILE_SIZE); // 8 Topo da Parede
                        fCtx.fillStyle = carpetBorderColor; fCtx.fillRect(TILE_SIZE * 9, 0, TILE_SIZE, TILE_SIZE); // 9 Borda do Tapete
                        fCtx.fillStyle = torchColor; fCtx.fillRect(TILE_SIZE * 10, 0, TILE_SIZE, TILE_SIZE); // 10 Tocha
                        fCtx.fillStyle = waterColor; fCtx.fillRect(TILE_SIZE * 11, 0, TILE_SIZE, TILE_SIZE); // 11 Água mágica
                        fCtx.fillStyle = crystalColor; fCtx.fillRect(TILE_SIZE * 12, 0, TILE_SIZE, TILE_SIZE); // 12 Cristal mágico
                        
                        // Adicionar detalhes aos tiles
                        // Tile 0 - Chão com padrão
                        fCtx.fillStyle = "#555555";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#666666";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 1 - Parede com textura
                        fCtx.fillStyle = "#444444";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#555555";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 2 - Pilar com detalhes
                        fCtx.fillStyle = "#999999";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        fCtx.fillStyle = "#aaaaaa";
                        fCtx.fillRect(6, 6, TILE_SIZE-12, TILE_SIZE-12);
                        
                        // Tile 3 - Parede com detalhes
                        fCtx.fillStyle = "#555555";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#666666";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        fCtx.fillStyle = "#777777";
                        fCtx.fillRect(6, 6, TILE_SIZE-12, TILE_SIZE-12);
                        
                        // Tile 4 - Tapete com padrão
                        fCtx.fillStyle = "#900000";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#a00000";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 5 - Altar com detalhes
                        fCtx.fillStyle = "#888888";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#999999";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 6 - Ladrilho escuro
                        fCtx.fillStyle = "#444444";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#555555";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 7 - Detalhe chão
                        fCtx.fillStyle = "#666666";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#777777";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 8 - Topo da parede
                        fCtx.fillStyle = "#333333";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#444444";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 9 - Borda do tapete
                        fCtx.fillStyle = "#ffcc00";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#ffdd00";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 10 - Tocha
                        fCtx.fillStyle = "#ff8800";
                        fCtx.fillRect(6, 6, TILE_SIZE-12, TILE_SIZE-12);
                        fCtx.fillStyle = "#ffaa00";
                        fCtx.fillRect(8, 8, TILE_SIZE-16, TILE_SIZE-16);
                        
                        // Tile 11 - Água mágica
                        fCtx.fillStyle = "#0088ff";
                        fCtx.fillRect(2, 2, TILE_SIZE-4, TILE_SIZE-4);
                        fCtx.fillStyle = "#00aaff";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        
                        // Tile 12 - Cristal mágico
                        fCtx.fillStyle = "#ff44ff";
                        fCtx.fillRect(4, 4, TILE_SIZE-8, TILE_SIZE-8);
                        fCtx.fillStyle = "#ff66ff";
                        fCtx.fillRect(6, 6, TILE_SIZE-12, TILE_SIZE-12);
                        
                        this.tileset = fallbackCanvas;
                        this.tilesetReady = true;
                        this.tiles_x = 16;
                    };
                    
                    this.map_data = [];
                    this.room_rect_tiles = {x: 0, y: 0, width: 0, height: 0};
                }

                loadMap(map_data, room_rect_tiles) {
                    this.map_data = map_data;
                    this.room_rect_tiles = room_rect_tiles;
                }

                isSolidAt(tileX, tileY) {
                    if (tileY >= 0 && tileY < this.map_data.length && tileX >= 0 && tileX < this.map_data[0].length) {
                        return SOLID_TILES.has(this.map_data[tileY][tileX]);
                    }
                    return true;
                }

                draw(ctx, camX, camY) {
                    if (!this.tilesetReady) return;
                    
                    const startCol = Math.floor(camX / this.tile_size);
                    const endCol = startCol + Math.ceil(SCREEN_WIDTH / this.tile_size) + 1;
                    const startRow = Math.floor(camY / this.tile_size);
                    const endRow = startRow + Math.ceil(SCREEN_HEIGHT / this.tile_size) + 1;

                    for (let y = startRow; y < endRow; y++) {
                        for (let x = startCol; x < endCol; x++) {
                            if (y >= 0 && y < this.map_data.length && x >= 0 && x < this.map_data[0].length) {
                                let tileId = this.map_data[y][x];
                                // Sempre desenha o chão base (tile 0) por baixo de tudo
                                let txSheet = 0, tySheet = 0;
                                ctx.drawImage(this.tileset, txSheet, tySheet, this.tile_size, this.tile_size, Math.floor(x * this.tile_size - camX), Math.floor(y * this.tile_size - camY), this.tile_size, this.tile_size);

                                // Desenha o tile real por cima
                                if (tileId !== 0) {
                                    txSheet = (tileId % this.tiles_x) * this.tile_size;
                                    tySheet = Math.floor(tileId / this.tiles_x) * this.tile_size;
                                    ctx.drawImage(this.tileset, txSheet, tySheet, this.tile_size, this.tile_size, Math.floor(x * this.tile_size - camX), Math.floor(y * this.tile_size - camY), this.tile_size, this.tile_size);
                                    
                                    // Adicionar efeitos animados para tiles específicos
                                    const screenX = Math.floor(x * this.tile_size - camX);
                                    const screenY = Math.floor(y * this.tile_size - camY);
                                    
                                    // Animação das tochas (tile 10)
                                    if (tileId === 10) {
                                        const time = Date.now() * 0.005;
                                        const flicker = Math.sin(time + x + y) * 0.3 + 0.7;
                                        ctx.save();
                                        ctx.globalAlpha = flicker;
                                        ctx.fillStyle = `rgba(255, 100, 0, ${flicker * 0.5})`;
                                        ctx.fillRect(screenX + 8, screenY + 4, 8, 8);
                                        ctx.restore();
                                    }
                                    
                                    // Animação da água mágica (tile 11)
                                    if (tileId === 11) {
                                        const time = Date.now() * 0.003;
                                        const wave = Math.sin(time + x * 0.5 + y * 0.3) * 0.2 + 0.8;
                                        ctx.save();
                                        ctx.globalAlpha = wave;
                                        ctx.fillStyle = `rgba(0, 150, 255, ${wave * 0.6})`;
                                        ctx.fillRect(screenX + 2, screenY + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                                        ctx.restore();
                                    }
                                    
                                    // Animação dos cristais mágicos (tile 12)
                                    if (tileId === 12) {
                                        const time = Date.now() * 0.004;
                                        const pulse = Math.sin(time + x + y) * 0.4 + 0.6;
                                        ctx.save();
                                        ctx.globalAlpha = pulse;
                                        ctx.fillStyle = `rgba(255, 0, 255, ${pulse * 0.8})`;
                                        ctx.fillRect(screenX + 6, screenY + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                                        ctx.restore();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            function generateThroneRoomMap(width, height) {
                let data = Array(height).fill(0).map(() => Array(width).fill(1));
                const room = { x: 8, y: 8, width: width - 16, height: height - 16 };
                
                // Cria a sala vazia com padrões de chão mais elaborados
                for (let y = room.y; y < room.y + room.height; y++) {
                    for (let x = room.x; x < room.x + room.width; x++) {
                        // Padrão de ladrilhos com detalhes
                        if ((x + y) % 2 === 0) {
                            data[y][x] = (Math.random() < 0.15) ? 7 : 0; // Ladrilho claro com detalhes
                        } else {
                            data[y][x] = (Math.random() < 0.08) ? 6 : 0; // Ladrilho escuro com menos detalhes
                        }
                    }
                }
                
                // Paredes elaboradas com diferentes tipos
                for (let y = room.y - 1; y < room.y + room.height + 1; y++) {
                    for (let x = room.x - 1; x < room.x + room.width + 1; x++) {
                        if (data[y] && data[y][x] !== 0 && data[y][x] !== 7 && data[y][x] !== 6) {
                            if (y + 1 < height && (data[y + 1][x] === 0 || data[y + 1][x] === 7 || data[y + 1][x] === 6)) {
                                data[y][x] = 8; // Topo da parede
                            } else {
                                // Paredes com diferentes materiais
                                if (x === room.x - 1 || x === room.x + room.width || y === room.y - 1 || y === room.y + room.height) {
                                    data[y][x] = (Math.random() < 0.3) ? 3 : 1; // Parede com detalhes
                                } else {
                                    data[y][x] = 1; // Parede normal
                                }
                            }
                        }
                    }
                }
                
                // Pilares decorativos em padrão mais elaborado
                const pillarPositions = [
                    {x: room.x + 8, y: room.y + 6},
                    {x: room.x + room.width - 9, y: room.y + 6},
                    {x: room.x + 8, y: room.y + room.height - 7},
                    {x: room.x + room.width - 9, y: room.y + room.height - 7},
                    {x: room.x + 15, y: room.y + 15},
                    {x: room.x + room.width - 16, y: room.y + 15},
                    {x: room.x + 15, y: room.y + room.height - 16},
                    {x: room.x + room.width - 16, y: room.y + room.height - 16}
                ];
                
                pillarPositions.forEach(pos => {
                    data[pos.y][pos.x] = 2; // Pilar principal
                    // Base do pilar
                    if (pos.y + 1 < height) data[pos.y + 1][pos.x] = 2;
                    if (pos.y + 2 < height) data[pos.y + 2][pos.x] = 2;
                });
                
                // Tapete elaborado com bordas decorativas
                const carpetW = 8;
                const carpetX = Math.floor(width / 2) - Math.floor(carpetW / 2);
                for (let y = room.y + 15; y < height - 8; y++) {
                    for (let x = carpetX; x < carpetX + carpetW; x++) {
                        if (x === carpetX || x === carpetX + carpetW - 1 || y === room.y + 15 || y === height - 9) {
                            data[y][x] = 9; // Borda do tapete
                        } else if (x === carpetX + 1 || x === carpetX + carpetW - 2 || y === room.y + 16 || y === height - 10) {
                            data[y][x] = 9; // Borda interna
                        } else {
                            data[y][x] = 4; // Tapete
                        }
                    }
                }
                
                // Altar elaborado com degraus
                const dais = { x: carpetX - 8, y: room.y + 6, width: carpetW + 16, height: 8 };
                for (let y = dais.y; y < dais.y + dais.height; y++) {
                    for (let x = dais.x; x < dais.x + dais.width; x++) {
                        if (y === dais.y) {
                            data[y][x] = 8; // Topo do altar
                        } else if (y === dais.y + 1) {
                            data[y][x] = 5; // Degrau superior
                        } else {
                            data[y][x] = 5; // Degraus inferiores
                        }
                    }
                }
                
                // Adicionar detalhes decorativos
                // Tochas nas paredes
                for (let x = room.x + 4; x < room.x + room.width - 4; x += 12) {
                    data[room.y - 1][x] = 10; // Tocha na parede norte
                    data[room.y + room.height][x] = 10; // Tocha na parede sul
                }
                for (let y = room.y + 4; y < room.y + room.height - 4; y += 15) {
                    data[y][room.x - 1] = 10; // Tocha na parede oeste
                    data[y][room.x + room.width] = 10; // Tocha na parede leste
                }
                
                // Adicionar poças de água mágica
                const waterPositions = [
                    {x: room.x + 12, y: room.y + 12},
                    {x: room.x + room.width - 13, y: room.y + 12},
                    {x: room.x + 12, y: room.y + room.height - 13},
                    {x: room.x + room.width - 13, y: room.y + room.height - 13}
                ];
                
                waterPositions.forEach(pos => {
                    data[pos.y][pos.x] = 11; // Água mágica
                    if (pos.x + 1 < width) data[pos.y][pos.x + 1] = 11;
                    if (pos.y + 1 < height) data[pos.y + 1][pos.x] = 11;
                    if (pos.x + 1 < width && pos.y + 1 < height) data[pos.y + 1][pos.x + 1] = 11;
                });
                
                // Adicionar cristais mágicos
                const crystalPositions = [
                    {x: room.x + 20, y: room.y + 20},
                    {x: room.x + room.width - 21, y: room.y + 20},
                    {x: room.x + 20, y: room.y + room.height - 21},
                    {x: room.x + room.width - 21, y: room.y + room.height - 21}
                ];
                
                crystalPositions.forEach(pos => {
                    data[pos.y][pos.x] = 12; // Cristal mágico
                });
                
                const playerStartPos = { x: (width / 2) * TILE_SIZE, y: (height - 12) * TILE_SIZE };
                const statuePos = { x: (dais.x + dais.width / 2) * TILE_SIZE, y: (dais.y + dais.height / 2 - 1) * TILE_SIZE };

                return { data, playerStartPos, roomRectTiles: room, statuePos };
            }

            // ---------------- CLASSES DE EFEITOS VISUAIS (VFX) ----------------
            class BaseVFX {
                constructor(x, y, lifetime) { this.x = x; this.y = y; this.lifetime = lifetime; this.age = 0; }
                update(dt) { this.age += dt; }
                isDead() { return this.age >= this.lifetime; }
                draw(ctx, camx, camy) {}
            }
            class FrostNovaEffect extends BaseVFX {
                constructor(x, y, maxRadius) { super(x, y, 0.6); this.maxRadius = maxRadius; }
                draw(ctx, camx, camy) {
                    const p = this.age / this.lifetime;
                    const r = this.maxRadius * p;
                    const a = 1 - p;
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.strokeStyle = `rgba(255,255,255, ${a})`;
                    ctx.fillStyle = `rgba(150,220,255, ${a})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x - camx, this.y - camy, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                }
            }
            class ExplosionEffect extends BaseVFX {
                constructor(x, y, radius, damage, game) {
                    super(x, y, 0.5);
                    this.radius = radius;
                    for (const e of game.all_enemies()) {
                        if (Math.hypot(e.x - this.x, e.y - this.y) <= this.radius) {
                            e.takeDamage(damage, game);
                        }
                    }
                }
                draw(ctx, camx, camy) {
                    const p = this.age / this.lifetime;
                    const r = this.radius * p;
                    const a = 1 - p;
                    ctx.save();
                    ctx.globalAlpha = a;
                    ctx.fillStyle = `rgba(255, 150, 50, ${a})`;
                    ctx.beginPath();
                    ctx.arc(this.x - camx, this.y - camy, r, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            class DamageText extends BaseVFX {
                constructor(x, y, damage, font, isCrit = false) {
                    super(x, y, 0.8);
                    this.text = `${Math.floor(damage)}`;
                    this.font = isCrit ? "bold 24px 'Silkscreen'" : font;
                    this.color = isCrit ? GOLD_COLOR : WHITE;
                    this.yVel = -40;
                }
                update(dt) { super.update(dt); this.y += this.yVel * dt; }
                draw(ctx, camx, camy) {
                    const alpha = 1 - (this.age / this.lifetime);
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.font = this.font;
                    ctx.fillStyle = this.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.text, this.x - camx, this.y - camy);
                    ctx.restore();
                }
            }
            class RewardText extends BaseVFX {
                constructor(x, y, text, color) {
                    super(x, y, 2.5);
                    this.text = text;
                    this.font = "bold 18px 'Silkscreen'";
                    this.color = color;
                    this.yVel = -30;
                }
                update(dt) { super.update(dt); this.y += this.yVel * dt; }
                draw(ctx, camx, camy) {
                    const p = this.age / this.lifetime;
                    let alpha = 1.0;
                    if (p > 0.7) {
                        alpha = (1.0 - p) / 0.3;
                    }
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.font = this.font;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = BLACK;
                    ctx.fillText(this.text, this.x - camx + 1, this.y - camy + 1);
                    ctx.fillStyle = this.color;
                    ctx.fillText(this.text, this.x - camx, this.y - camy);
                    ctx.restore();
                }
            }
            class TeleportEffect extends BaseVFX {
                constructor(x, y) { super(x, y, 0.4); }
                draw(ctx, camx, camy) {
                    const p = this.age / this.lifetime;
                    const radius = 40 * p;
                    const alpha = 1 - p;
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = `rgba(200, 180, 255, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(this.x - camx, this.y - camy, radius, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // ---------------- CLASSES DE HABILIDADES ----------------
            class BaseAbility {
                constructor(p) { this.player = p; this.name = "Base"; this.manaCost = 10; this.cooldown = 5.0; this.cooldownTimer = 0; }
                update(dt) { this.cooldownTimer = Math.max(0, this.cooldownTimer - dt); }
                canCast() { return this.cooldownTimer === 0 && this.player.mana >= this.manaCost; }
                activate(g, m) {
                    if (this.canCast()) {
                        this.player.mana -= this.manaCost;
                        this.cooldownTimer = this.cooldown * (1 - this.player.ability_cooldown_reduction);
                        return true;
                    }
                    return false;
                }
                drawIcon(ctx, r) { 
                    ctx.fillStyle = "#646464"; 
                    ctx.fillRect(r.x, r.y, r.width, r.height);
                }
            }
            class FrostNova extends BaseAbility {
                constructor(p) { super(p); this.name = "Nova Congelante"; this.manaCost = 25; this.cooldown = 12.0; this.radius = 250; this.damage = 20; this.freezeDuration = 2.0; }
                activate(g, m) {
                    if (super.activate(g, m)) {
                        g.vfx_effects.push(new FrostNovaEffect(this.player.x, this.player.y, this.radius));
                        for (const e of g.all_enemies()) {
                            if (Math.hypot(e.x - this.player.x, e.y - this.player.y) <= this.radius) {
                                e.takeDamage(this.damage * this.player.damageMultiplier, g);
                                e.applyStatus('frozen', this.freezeDuration);
                            }
                        }
                    }
                }
                drawIcon(ctx, r) {
                    ctx.fillStyle = "#64C8FF"; 
                    ctx.fillRect(r.x, r.y, r.width, r.height);
                    ctx.fillStyle = WHITE;
                    ctx.beginPath();
                    ctx.moveTo(r.x + r.width/2, r.y + 5);
                    ctx.lineTo(r.x + 5, r.y + r.height/2);
                    ctx.lineTo(r.x + r.width/2, r.y + r.height - 5);
                    ctx.lineTo(r.x + r.width - 5, r.y + r.height/2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
            class Teleport extends BaseAbility {
                constructor(p) { super(p); this.name = "Teleporte"; this.manaCost = 8; this.cooldown = 2.5; this.teleportDistance = 150; }
                activate(g, m) {
                    if (super.activate(g, m)) {
                        const {x: mx, y: my} = m;
                        let dx = mx - this.player.x, dy = my - this.player.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 0) { dx /= dist; dy /= dist; }
                        
                        for (let i = 5; i > 0; i--) {
                            const checkDist = this.teleportDistance * (i / 5);
                            const newX = this.player.x + dx * checkDist;
                            const newY = this.player.y + dy * checkDist;
                            if (!g.map.isSolidAt(Math.floor(newX / TILE_SIZE), Math.floor(newY / TILE_SIZE))) {
                                g.vfx_effects.push(new TeleportEffect(this.player.x, this.player.y));
                                this.player.x = newX;
                                this.player.y = newY;
                                this.player.rect.x = this.player.x - this.player.radius;
                                this.player.rect.y = this.player.y - this.player.radius;
                                g.vfx_effects.push(new TeleportEffect(this.player.x, this.player.y));
                                return true;
                            }
                        }
                        this.player.mana += this.manaCost; this.cooldownTimer = 0; return false;
                    }
                    return false;
                }
                 drawIcon(ctx, r) {
                     ctx.fillStyle = "#B464FF"; 
                     ctx.fillRect(r.x, r.y, r.width, r.height);
                     ctx.strokeStyle = WHITE; ctx.lineWidth = 3;
                     ctx.beginPath();
                     ctx.moveTo(r.x + 5, r.y + r.height/2);
                     ctx.lineTo(r.x + r.width - 5, r.y + r.height/2);
                     ctx.stroke();
                     ctx.fillStyle = WHITE;
                     ctx.beginPath();
                     ctx.moveTo(r.x + r.width - 10, r.y + 10);
                     ctx.lineTo(r.x + r.width - 5, r.y + r.height/2);
                     ctx.lineTo(r.x + r.width - 10, r.y + r.height - 10);
                     ctx.closePath();
                     ctx.fill();
                 }
            }
            
            // ---------------- DEFINIÇÕES DE DADOS ----------------
            const STARTING_ATTACKS = [
                {"title":"Disparo Triplo Perfurante","description":"Dispara 3 projéteis em cone que atravessam um inimigo cada.","type":"attack_choice","category":"attack","id":"triple_piercing"},
                {"title":"Disparo Estelar","description":"Dispara 8 projéteis em todas as direções.","type":"attack_choice","category":"attack","id":"omni_shot"},
                {"title":"Tiro Explosivo","description":"Dispara um projétil que explode ao atingir um alvo, causando dano em área.","type":"attack_choice","category":"attack","id":"explosive_shot"},
            ];
            const PASSIVE_CARDS=[{"title":"Vitalidade","description":"Aumenta a Vida Máxima em 20.","type":"passive","category":"support", "apply": p => p.base_max_hp += 20, "get_details": p => `Vida Máxima: ${p.max_hp} -> ${p.max_hp+20}`},{"title":"Fogo Mais Quente","description":"Aumenta o dano base dos projéteis em 5.","type":"passive","category":"attack", "apply": p => p.base_projectile_damage += 5, "get_details": p => `Dano: ${p.projectile_damage} -> ${p.projectile_damage+5}`},{"title":"Mente Expandida","description":"Aumenta sua Mana Máxima em 25.","type":"passive","category":"support", "apply": p => p.base_max_mana += 25, "get_details": p => `Mana Máxima: ${p.max_mana} -> ${p.max_mana+25}`}];
            const ABILITY_CARDS=[{"title":"HABILIDADE: Nova Congelante","description":"Cria uma explosão de gelo que congela e causa dano.","type":"ability","category":"ability","ability_class":FrostNova,"get_details": (ac, p) => `Custo: ${new ac(p).manaCost} Mana`},{"title":"HABILIDADE: Teleporte","description":"Teleporta uma curta distância.","type":"ability","category":"ability","ability_class":Teleport,"get_details": (ac, p) => `Custo: ${new ac(p).manaCost} Mana`}];
            const STARTING_BLESSINGS = [{"title":"Bênção do Sábio","description":"Aumenta todo o ganho de experiência em 25%.","type":"passive","category":"support", "apply":p => p.xp_multiplier += 0.25, "get_details":p => "XP Ganho: 100% -> 125%"},{"title":"Bênção do Vampiro","description":"Recupera 1 de vida por cada inimigo derrotado.","type":"passive","category":"support", "apply":p => p.lifesteal_on_kill += 1, "get_details":p => "Vida por Morte: 0 -> 1"},{"title":"Bênção do Berserker","description":"Aumenta todo o dano causado em 25%.","type":"passive","category":"attack", "apply":p => p.base_damage_multiplier += 0.25, "get_details":p => "Dano Total: 100% -> 125%"}];
            
            const EQUIPMENT_ITEMS = {
                'steel_helmet': { id: 'steel_helmet', name: 'Capacete de Aço', type: 'helmet', description: '+10 Vida Máx', stats: { max_hp: 10 } },
                'iron_chestplate': { id: 'iron_chestplate', name: 'Peitoral de Ferro', type: 'chest', description: '+15 Vida Máx', stats: { max_hp: 15 } },
                'leather_gloves': { id: 'leather_gloves', name: 'Luvas de Couro', type: 'gloves', description: '+5% Dano', stats: { damage_multiplier: 0.05 } },
                'swift_boots': { id: 'swift_boots', name: 'Botas da Rapidez', type: 'boots', description: '+10% Vel. Movimento', stats: { speed_multiplier: 0.10 } },
                'talisman_of_power': { id: 'talisman_of_power', name: 'Talismã do Poder', type: 'talisman', description: '+3 Dano Projétil', stats: { projectile_damage: 3 } },
            };

            // --- NOVA ÁRVORE DE TALENTOS EXPANDIDA ---
            const SKILL_TREE_NODES = {
                // --- Trilha de Força (Ofensiva) ---
                'dmg_1': { id: 'dmg_1', name: 'Força I', description: '+3 Dano Projétil', cost: 1, dependencies: [], x: 400, y: 180, apply: p => p.base_projectile_damage += 3 },
                'atk_speed_1': { id: 'atk_speed_1', name: 'Agilidade I', description: '-5% Cooldown de Ataque', cost: 2, dependencies: ['dmg_1'], x: 500, y: 240, apply: p => p.base_attack_cooldown_multiplier -= 0.05 },
                'crit_1': { id: 'crit_1', name: 'Golpes Precisos', description: '+5% Chance de Crítico', cost: 2, dependencies: ['dmg_1'], x: 300, y: 240, apply: p => p.base_crit_chance += 0.05 },
                'dmg_2': { id: 'dmg_2', name: 'Força II', description: '+5 Dano Projétil', cost: 3, dependencies: ['atk_speed_1', 'crit_1'], x: 400, y: 300, apply: p => p.base_projectile_damage += 5 },
                'crit_dmg_1': { id: 'crit_dmg_1', name: 'Golpes Brutais', description: '+25% Dano Crítico', cost: 3, dependencies: ['dmg_2'], x: 300, y: 360, apply: p => p.base_crit_damage += 0.25 },
                'pierce_1': { id: 'pierce_1', name: 'Tiros Perfurantes', description: '+1 Perfuração', cost: 3, dependencies: ['dmg_2'], x: 500, y: 360, apply: p => p.base_pierce += 1 },
                'ultimate_offense': { id: 'ultimate_offense', name: 'Fúria Implacável', description: '+15% Dano e Vel. de Ataque', cost: 5, dependencies: ['crit_dmg_1', 'pierce_1'], x: 400, y: 440, apply: p => { p.base_damage_multiplier += 0.15; p.base_attack_cooldown_multiplier -= 0.15; } },

                // --- Trilha de Vitalidade (Defensiva) ---
                'hp_1': { id: 'hp_1', name: 'Vigor I', description: '+15 Vida Máxima', cost: 1, dependencies: [], x: 150, y: 250, apply: p => p.base_max_hp += 15 },
                'regen_1': { id: 'regen_1', name: 'Regeneração I', description: '+0.5 HP/s', cost: 2, dependencies: ['hp_1'], x: 150, y: 320, apply: p => p.base_hp_regen += 0.5 },
                'armor_1': { id: 'armor_1', name: 'Pele de Pedra', description: 'Reduz 5% do dano recebido', cost: 3, dependencies: ['regen_1'], x: 220, y: 380, apply: p => p.base_damage_reduction += 0.05 },
                'hp_2': { id: 'hp_2', name: 'Vigor II', description: '+25 Vida Máxima', cost: 2, dependencies: ['regen_1'], x: 80, y: 380, apply: p => p.base_max_hp += 25 },
                'ultimate_defense': { id: 'ultimate_defense', name: 'Baluarte Inabalável', description: '+50 Vida e +1 HP/s', cost: 5, dependencies: ['armor_1', 'hp_2'], x: 150, y: 440, apply: p => { p.base_max_hp += 50; p.base_hp_regen += 1; } },

                // --- Trilha de Sabedoria (Utilidade/Magia) ---
                'mana_1': { id: 'mana_1', name: 'Intelecto I', description: '+20 Mana Máxima', cost: 1, dependencies: [], x: 650, y: 250, apply: p => p.base_max_mana += 20 },
                'mana_regen_1': { id: 'mana_regen_1', name: 'Clareza I', description: '+1 Mana/s', cost: 2, dependencies: ['mana_1'], x: 650, y: 320, apply: p => p.base_mana_regen += 1 },
                'cdr_1': { id: 'cdr_1', name: 'Sincronia I', description: '-10% Recarga de Habilidades', cost: 3, dependencies: ['mana_regen_1'], x: 580, y: 380, apply: p => p.base_ability_cooldown_reduction += 0.10 },
                'xp_1': { id: 'xp_1', name: 'Aprendizado', description: '+10% Ganho de XP', cost: 3, dependencies: ['mana_regen_1'], x: 720, y: 380, apply: p => p.xp_multiplier_talent_bonus += 0.10 },
                'ultimate_utility': { id: 'ultimate_utility', name: 'Arquimago', description: '+50 Mana e -15% Recarga de Habilidades', cost: 5, dependencies: ['cdr_1', 'xp_1'], x: 650, y: 440, apply: p => { p.base_max_mana += 50; p.base_ability_cooldown_reduction += 0.15; } },
            };

            // ---------------- CLASSES DE PROJÉTEIS ----------------
            class Projectile {
                constructor(x,y,dx,dy,damage,speed,radius,pierce=1) {
                    this.x = x; this.y = y; this.dx = dx; this.dy = dy;
                    this.damage = damage; this.speed = speed; this.age = 0;
                    this.radius = radius; this.pierce_count = pierce;
                    this.hit_enemies = new Set();
                    this.isCrit = false;
                }
                update(dt) { this.x += this.dx * this.speed * dt; this.y += this.dy * this.speed * dt; this.age += dt; }
                isDead() { return this.age > 2.0; }
                draw(ctx, cx, cy) { 
                    const drawX = this.x - cx;
                    const drawY = this.y - cy;
                    const radius = this.isCrit ? this.radius * 1.5 : this.radius;
                    const color = this.isCrit ? GOLD_COLOR : "#FF6400";

                    // Efeito de rastro
                    const trailLength = 5;
                    for (let i = 0; i < trailLength; i++) {
                        const p = i / trailLength;
                        const trailX = drawX - this.dx * this.speed * p * 0.05;
                        const trailY = drawY - this.dy * this.speed * p * 0.05;
                        ctx.beginPath();
                        ctx.arc(trailX, trailY, radius * (1 - p), 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(255, 100, 0, ${0.5 * (1 - p)})`;
                        ctx.fill();
                    }
                    
                    // Brilho do projétil principal
                    const grad = ctx.createRadialGradient(drawX, drawY, radius * 0.2, drawX, drawY, radius);
                    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    grad.addColorStop(0.5, color);
                    grad.addColorStop(1, 'rgba(255, 100, 0, 0)');

                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            class ExplosiveProjectile extends Projectile {
                constructor(x,y,dx,dy,damage,speed,radius) {
                    super(x,y,dx,dy,damage,speed,radius,1);
                }
                draw(ctx, cx, cy) {
                    const drawX = this.x - cx;
                    const drawY = this.y - cy;
                    const radius = this.radius + Math.sin(this.age * 50) * 2; // Efeito de pulsação
                    const color = this.isCrit ? "#FFFF00" : "#FFC800";
                    
                    // Brilho externo
                    const grad = ctx.createRadialGradient(drawX, drawY, radius * 0.5, drawX, drawY, radius * 1.5);
                    grad.addColorStop(0, 'rgba(255, 200, 0, 0.8)');
                    grad.addColorStop(1, 'rgba(255, 60, 0, 0)');
                    ctx.fillStyle = grad;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Núcleo
                    ctx.fillStyle = "#FF3C00";
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Núcleo interno
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            class EnemyProjectile extends Projectile {
                constructor(x,y,dx,dy) {
                    super(x,y,dx,dy,10,250,5);
                    this.color = "#9600FF";
                }
                draw(ctx, cx, cy) {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x - cx, this.y - cy, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // ---------------- CLASSES DE ENTIDADES ----------------
            class Statue {
                constructor(x, y) {
                    this.x = x; this.y = y; this.size = TILE_SIZE * 1.5;
                }
                draw(ctx, cx, cy) {
                    const drawX = this.x - cx;
                    const drawY = this.y - cy;
                    ctx.fillStyle = '#6c757d';
                    ctx.fillRect(drawX - this.size / 2, drawY - this.size / 2, this.size, this.size);
                    ctx.strokeStyle = '#343a40';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(drawX - this.size / 2, drawY - this.size / 2, this.size, this.size);
                    ctx.fillStyle = '#adb5bd';
                    ctx.fillRect(drawX - 5, drawY - 15, 10, 10);
                }
            }
            class Chest {
                constructor(x, y) {
                    this.x = x; this.y = y; this.size = TILE_SIZE; this.rect = { x: x, y: y, width: this.size, height: this.size };
                }
                draw(ctx, cx, cy) {
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(this.x - cx, this.y - cy, this.size, this.size);
                    ctx.fillStyle = GOLD_COLOR;
                    ctx.fillRect(this.x - cx + 4, this.y - cy + this.size / 2 - 4, this.size - 8, 8);
                    ctx.strokeStyle = BLACK;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - cx, this.y - cy, this.size, this.size);
                }
            }
            class BaseEnemy {
                constructor(x, y) {
                    this.x = x; this.y = y; this.radius = 15; this.max_hp = 30; this.hp = 30;
                    this.speed = 80; this.damage = 10; this.xp_reward = 10; this.soul_drop = 2; this.color = "#C83232";
                    this.status_effects = {}; this.hit_flash = 0;
                    
                    this.spriteSheet = new Image();
                    this.spriteSheet.src = baseEnemySpriteSheet.src;
                    this.animTimer = 0;
                    this.animFrame = 0;
                }
                update(dt, p, g) {
                    if (this.status_effects['frozen']) {
                        this.status_effects['frozen'] -= dt;
                        if (this.status_effects['frozen'] <= 0) delete this.status_effects['frozen'];
                        return;
                    }

                    this.animTimer += dt;
                    if (this.animTimer > 0.12) { // Animação mais fluida (era 0.3)
                        this.animFrame = (this.animFrame + 1) % 4;
                        this.animTimer = 0;
                    }

                    const dx = p.x - this.x; const dy = p.y - this.y;
                    const d = Math.hypot(dx, dy);
                    if (d > 0) {
                        this.x += (dx / d) * this.speed * dt;
                        this.y += (dy / d) * this.speed * dt;
                    }
                    if (this.hit_flash > 0) this.hit_flash = Math.max(0, this.hit_flash - dt);
                }
                takeDamage(a, g, isCrit = false) {
                    this.hp -= a; this.hit_flash = 0.2;
                    if (g) g.vfx_effects.push(new DamageText(this.x, this.y - this.radius, a, g.font_damage, isCrit));
                }
                applyStatus(e, d) { this.status_effects[e] = d; }
                draw(ctx, cx, cy) {
                    const drawX = this.x - cx - this.radius;
                    const drawY = this.y - cy - this.radius;

                    // Sombra do sprite
                    ctx.globalAlpha = 0.3;
                    ctx.drawImage(this.spriteSheet, this.animFrame * 32, 0, 32, 32, drawX + 2, drawY + 2, this.radius * 2, this.radius * 2);
                    ctx.globalAlpha = 1.0;

                    // Sprite principal
                    ctx.drawImage(this.spriteSheet, this.animFrame * 32, 0, 32, 32, drawX, drawY, this.radius * 2, this.radius * 2);

                    // Efeito de brilho sutil
                    ctx.globalAlpha = 0.1;
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(drawX + 1, drawY + 1, this.radius * 2 - 2, 2);
                    ctx.fillRect(drawX + 1, drawY + 1, 2, this.radius * 2 - 2);
                    ctx.globalAlpha = 1.0;

                    if (this.hit_flash > 0) {
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = "white";
                        ctx.fillRect(drawX, drawY, this.radius * 2, this.radius * 2);
                        ctx.globalAlpha = 1.0;
                    }
                    if (this.status_effects['frozen']) {
                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = "#6496FF";
                        ctx.fillRect(drawX, drawY, this.radius * 2, this.radius * 2);
                        ctx.globalAlpha = 1.0;
                    }
                    
                    if (this.hp < this.max_hp && this.hp > 0) {
                        drawBar(ctx, this.x - cx - this.radius, this.y - cy - this.radius - 12, this.radius * 2, 7, this.hp, this.max_hp, HP_COLOR);
                    }
                }
            }
            class MimicEnemy extends BaseEnemy {
                constructor(x, y) {
                    super(x, y);
                    this.max_hp = 150; this.hp = 150; this.radius = 18; this.speed = 120;
                    this.damage = 25; this.xp_reward = 50; this.soul_drop = 25;
                    this.spriteSheet.src = mimicEnemySpriteSheet.src;
                }
            }
            class SlimeEnemy extends BaseEnemy {
                constructor(x, y, round) {
                    super(x, y);
                    this.max_hp = 60 * (1 + round * 0.1); this.hp = this.max_hp; this.radius = 17;
                    this.speed = 50 * (1 + round * 0.05); this.damage = 8 * (1 + round * 0.1);
                    this.xp_reward = 8; this.soul_drop = 3;
                    this.spriteSheet.src = slimeEnemySpriteSheet.src;
                }
            }
            class BatEnemy extends BaseEnemy {
                constructor(x, y, round) {
                    super(x, y);
                    this.max_hp = 20 * (1 + round * 0.1); this.hp = this.max_hp; this.radius = 12;
                    this.speed = 150 * (1 + round * 0.05); this.damage = 12 * (1 + round * 0.1);
                    this.xp_reward = 12; this.soul_drop = 4;
                    this.spriteSheet.src = batEnemySpriteSheet.src;
                    this.angle = 0; this.waveTimer = Math.random() * Math.PI * 2;
                }

                update(dt, p, g) {
                    if (this.status_effects['frozen']) {
                        this.status_effects['frozen'] -= dt;
                        if (this.status_effects['frozen'] <= 0) delete this.status_effects['frozen'];
                        return;
                    }

                    this.animTimer += dt;
                    if (this.animTimer > 0.08) { // Animação mais fluida (era 0.2)
                        this.animFrame = (this.animFrame + 1) % 4;
                        this.animTimer = 0;
                    }

                    const dx_player = p.x - this.x; const dy_player = p.y - this.y;
                    this.angle = Math.atan2(dy_player, dx_player);
                    
                    this.waveTimer += dt * 5;
                    const wave_offset = Math.sin(this.waveTimer) * 60; // Degrees
                    const final_angle = this.angle + (wave_offset * Math.PI / 180);
                    
                    const d = Math.hypot(dx_player, dy_player);
                    if (d > 0) {
                        this.x += Math.cos(final_angle) * this.speed * dt;
                        this.y += Math.sin(final_angle) * this.speed * dt;
                    }
                    if (this.hit_flash > 0) this.hit_flash = Math.max(0, this.hit_flash - dt);
                }
            }
            class RangedEnemy extends BaseEnemy {
                constructor(x, y, round) {
                    super(x, y);
                    this.max_hp = 25 * (1 + round * 0.1); this.hp = this.max_hp; this.radius = 15;
                    this.speed = 70 * (1 + round * 0.05); this.damage = 15 * (1 + round * 0.1);
                    this.xp_reward = 15; this.soul_drop = 8;
                    this.spriteSheet.src = rangedEnemySpriteSheet.src;
                    this.attack_range = 300; this.attack_cooldown = 2.5 - (round * 0.02);
                    this.attack_timer = Math.random() * this.attack_cooldown;
                }

                update(dt, p, g) {
                    if (this.status_effects['frozen']) {
                        this.status_effects['frozen'] -= dt;
                        if (this.status_effects['frozen'] <= 0) delete this.status_effects['frozen'];
                        return;
                    }
                    
                    this.animTimer += dt;
                    if (this.animTimer > 0.15) { // Animação mais fluida (era 0.4)
                        this.animFrame = (this.animFrame + 1) % 4;
                        this.animTimer = 0;
                    }

                    const dx = p.x - this.x; const dy = p.y - this.y;
                    const d = Math.hypot(dx, dy);

                    if (d < this.attack_range - 50) { 
                        this.x -= (dx / d) * this.speed * dt * 0.8;
                        this.y -= (dy / d) * this.speed * dt * 0.8;
                    } else if (d > this.attack_range) { 
                        this.x += (dx / d) * this.speed * dt;
                        this.y += (dy / d) * this.speed * dt;
                    }
                    
                    this.attack_timer -= dt;
                    if (this.attack_timer <= 0 && d < this.attack_range + 20) {
                        const proj_dx = dx / d; const proj_dy = dy / d;
                        g.enemy_projectiles.push(new EnemyProjectile(this.x, this.y, proj_dx, proj_dy));
                        this.attack_timer = this.attack_cooldown;
                    }

                    if (this.hit_flash > 0) this.hit_flash = Math.max(0, this.hit_flash - dt);
                }
            }
            class BossEnemy extends BaseEnemy {
                constructor(x, y, round) {
                    super(x, y);
                    const scale = 1 + (round / 10 - 1) * 0.5;
                    this.max_hp = 5000 * scale; this.hp = this.max_hp; this.radius = 48; // Aumentado o raio
                    this.speed = 60 * (1 + (round/10 - 1) * 0.1); this.xp_reward = 200 * scale;
                    this.soul_drop = 500 * scale; this.damage = 25 * scale;
                    this.spriteSheet.src = bossEnemySpriteSheet.src;
                    this.attack_state = 'moving'; this.original_speed = this.speed;
                    this.fan_shot_timer = 3.0; this.dash_timer = 8.0; this.dash_charge_timer = 1.0;
                }
                update(dt, p, g) {
                    super.update(dt, p, g); // Chama o update base para animação
                    if (this.status_effects['frozen']) return; // Apenas impede movimento e ataques, mas não impede de tomar dano

                    if (this.attack_state === 'moving') {
                        this.fan_shot_timer -= dt; this.dash_timer -= dt;
                        const dx = p.x - this.x; const dy = p.y - this.y;
                        const d = Math.hypot(dx, dy);
                        if (d > this.radius + p.radius) {
                            this.x += (dx / d) * this.speed * dt;
                            this.y += (dy / d) * this.speed * dt;
                        }
                        if (this.dash_timer <= 0) this.attack_state = 'charging_dash';
                        else if (this.fan_shot_timer <= 0) {
                            this.fan_shot_attack(p, g); this.fan_shot_timer = 3.0;
                        }
                    } else if (this.attack_state === 'charging_dash') {
                        this.dash_charge_timer -= dt;
                        if (this.dash_charge_timer <= 0) {
                            this.attack_state = 'dashing'; this.speed *= 5;
                            const dx = p.x - this.x; const dy = p.y - this.y;
                            const d = Math.hypot(dx, dy);
                            this.dash_vector = (d > 0) ? { x: dx / d, y: dy / d } : { x: 0, y: -1 };
                            this.dash_duration = 0.7;
                        }
                    } else if (this.attack_state === 'dashing') {
                        this.x += this.dash_vector.x * this.speed * dt;
                        this.y += this.dash_vector.y * this.speed * dt;
                        this.dash_duration -= dt;
                        if (this.dash_duration <= 0) {
                            this.speed = this.original_speed; this.attack_state = 'moving';
                            this.dash_timer = 8.0; this.dash_charge_timer = 1.0;
                        }
                    }
                }
                fan_shot_attack(p, g) {
                    const dx = p.x - this.x, dy = p.y - this.y;
                    const base_angle = Math.atan2(dy, dx);
                    for (let i = -2; i <= 2; i++) {
                        const angle = base_angle + (i * 15 * Math.PI / 180);
                        const proj_dx = Math.cos(angle), proj_dy = Math.sin(angle);
                        g.enemy_projectiles.push(new EnemyProjectile(this.x, this.y, proj_dx, proj_dy));
                    }
                }
                draw(ctx, cx, cy) {
                    // Chama o draw base, que lida com o sprite e efeitos
                    super.draw(ctx, cx, cy);
                    
                    if (this.attack_state === 'charging_dash') {
                          ctx.globalAlpha = 0.5;
                          ctx.fillStyle = "red";
                          ctx.fillRect(this.x - cx - this.radius, this.y - cy - this.radius, this.radius * 2, this.radius * 2);
                          ctx.globalAlpha = 1.0;
                    }
                }
            }

            // ---------------- CLASSE DO JOGADOR ----------------
            class Player {
                constructor(x, y) {
                    this.x = x; this.y = y; this.radius = 16;
                    this.level = 1; this.xp = 0; this.xp_to_next_level = 100;
                    this.souls = 0;
                    
                    this.base_max_hp = 100;
                    this.base_max_mana = 50;
                    this.base_hp_regen = 1.5;
                    this.base_mana_regen = 2.5;
                    this.base_speed = 200;
                    this.base_projectile_damage = 10;
                    this.base_projectile_speed = 400; 
                    this.base_damage_multiplier = 1.0;
                    this.base_pierce = 1;
                    this.base_attack_cooldown_multiplier = 1.0;
                    this.base_crit_chance = 0.05; 
                    this.base_crit_damage = 1.5; 
                    this.base_damage_reduction = 0; 
                    this.base_ability_cooldown_reduction = 0; 
                    this.xp_multiplier_talent_bonus = 0;

                    this.projectiles = []; this.abilities = {};
                    this.attack_timer = 0;
                    this.rect = { x: x - this.radius, y: y - this.radius, width: this.radius * 2, height: this.radius * 2 };
                    
                    this.xp_multiplier = 1.0; this.lifesteal_on_kill = 0;
                    
                    this.attack_type = 'single'; this.collected_cards = []; this.next_ability_slot = 1;
                    
                    this.inventory = [];
                    this.equipment = { helmet: null, chest: null, gloves: null, boots: null, talisman: null };

                    this.talentPoints = 0;
                    this.unlockedTalents = new Set();

                    this.spriteSheet = new Image();
                    this.spriteSheet.src = playerSpriteSheet.src;
                    this.animTimer = 0;
                    this.animFrame = 0;
                    
                    this.recalculateStats();
                    this.hp = this.max_hp;
                    this.mana = this.max_mana;
                }

                recalculateStats() {
                    this.max_hp = this.base_max_hp;
                    this.max_mana = this.base_max_mana;
                    this.hp_regen = this.base_hp_regen;
                    this.mana_regen = this.base_mana_regen;
                    this.speed = this.base_speed;
                    this.projectile_damage = this.base_projectile_damage;
                    this.projectile_speed = this.base_projectile_speed; 
                    this.damage_multiplier = this.base_damage_multiplier;
                    this.pierce = this.base_pierce;
                    this.attack_cooldown_multiplier = this.base_attack_cooldown_multiplier;
                    this.crit_chance = this.base_crit_chance;
                    this.crit_damage = this.base_crit_damage;
                    this.damage_reduction = this.base_damage_reduction; 
                    this.ability_cooldown_reduction = this.base_ability_cooldown_reduction; 

                    for (const slot in this.equipment) {
                        const item = this.equipment[slot];
                        if (item && item.stats) {
                            if (item.stats.max_hp) this.max_hp += item.stats.max_hp;
                            if (item.stats.damage_multiplier) this.damage_multiplier += item.stats.damage_multiplier;
                            if (item.stats.speed_multiplier) this.speed *= (1 + item.stats.speed_multiplier);
                            if (item.stats.projectile_damage) this.projectile_damage += item.stats.projectile_damage;
                        }
                    }
                    
                    this.xp_multiplier = 1.0;
                    this.lifesteal_on_kill = 0;
                    this.collected_cards.forEach(card => {
                        if (card.title === "Bênção do Sábio") this.xp_multiplier += 0.25;
                        if (card.title === "Bênção do Vampiro") this.lifesteal_on_kill += 1;
                    });
                    
                    this.attack_cooldown = 0.38 * this.attack_cooldown_multiplier;

                    this.hp = Math.min(this.hp, this.max_hp);
                    this.mana = Math.min(this.mana, this.max_mana);
                }

                equipItem(item) {
                    const slot = item.type;
                    if (!slot || !this.equipment.hasOwnProperty(slot)) return;

                    const currentIndex = this.inventory.indexOf(item);
                    if (currentIndex > -1) {
                         this.inventory.splice(currentIndex, 1);
                    }

                    if (this.equipment[slot]) {
                        this.inventory.push(this.equipment[slot]);
                    }

                    this.equipment[slot] = item;
                    this.recalculateStats();
                }

                unequipItem(slot) {
                    if (this.equipment[slot]) {
                        this.inventory.push(this.equipment[slot]);
                        this.equipment[slot] = null;
                        this.recalculateStats();
                    }
                }
                
                unlockTalent(talentId) {
                    const talent = SKILL_TREE_NODES[talentId];
                    if (!talent || this.unlockedTalents.has(talentId)) return;
                    
                    const canUnlock = talent.dependencies.every(dep => this.unlockedTalents.has(dep));

                    if (this.talentPoints >= talent.cost && canUnlock) {
                        this.talentPoints -= talent.cost;
                        this.unlockedTalents.add(talentId);
                        talent.apply(this);
                        this.recalculateStats();
                    }
                }

                update(dt, mwp, game_map) {
                    let dx = 0, dy = 0;
                    if (keys[keybinds.UP]) dy -= 1;
                    if (keys[keybinds.DOWN]) dy += 1;
                    if (keys[keybinds.LEFT]) dx -= 1;
                    if (keys[keybinds.RIGHT]) dx += 1;

                    if (dx !== 0 || dy !== 0) {
                        this.animTimer += dt;
                        if(this.animTimer > 0.08) { // Animação mais fluida (era 0.15)
                            this.animFrame = (this.animFrame + 1) % 4;
                            this.animTimer = 0;
                        }
                        const l = Math.hypot(dx, dy);
                        const vx = dx / l * this.speed * dt;
                        const vy = dy / l * this.speed * dt;

                        this.x += vx;
                        this.checkCollision('x', vx, game_map);

                        this.y += vy;
                        this.checkCollision('y', vy, game_map);
                    } else {
                        this.animFrame = 0;
                    }
                    this.hp = Math.min(this.max_hp, this.hp + this.hp_regen * dt);
                    this.mana = Math.min(this.max_mana, this.mana + this.mana_regen * dt);
                    this.projectiles.forEach(p => p.update(dt));
                    this.projectiles = this.projectiles.filter(p => !p.isDead());
                    Object.values(this.abilities).forEach(ability => ability.update(dt));
                    this.attack_timer -= dt;
                    if (this.attack_timer <= 0) {
                        this.attack(mwp.x, mwp.y);
                        this.attack_timer = this.attack_cooldown;
                    }
                }
                checkCollision(dir, vel, m) {
                    this.rect.x = this.x - this.radius;
                    this.rect.y = this.y - this.radius;
                    
                    for (let ty = Math.floor(this.rect.y / TILE_SIZE); ty <= Math.floor((this.rect.y + this.rect.height) / TILE_SIZE); ty++) {
                        for (let tx = Math.floor(this.rect.x / TILE_SIZE); tx <= Math.floor((this.rect.x + this.rect.width) / TILE_SIZE); tx++) {
                            if (m.isSolidAt(tx, ty)) {
                                const tr = { x: tx * TILE_SIZE, y: ty * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE };
                                if (this.rect.x < tr.x + tr.width && this.rect.x + this.rect.width > tr.x &&
                                    this.rect.y < tr.y + tr.height && this.rect.y + this.rect.height > tr.y) {
                                    if (dir === 'x') {
                                        if (vel > 0) this.x = tr.x - this.radius;
                                        else this.x = tr.x + tr.width + this.radius;
                                    } else if (dir === 'y') {
                                        if (vel > 0) this.y = tr.y - this.radius;
                                        else this.y = tr.y + tr.height + this.radius;
                                    }
                                }
                            }
                        }
                    }
                }
                attack(tx, ty) {
                    const dx = tx - this.x, dy = ty - this.y;
                    const l = Math.hypot(dx, dy);
                    if (l <= 0) return;
                    
                    let final_damage = this.projectile_damage * this.damage_multiplier;
                    const isCrit = Math.random() < this.crit_chance;
                    if (isCrit) {
                        final_damage *= this.crit_damage;
                    }

                    const createProjectile = (px, py, pDx, pDy, pPierce) => {
                       const proj = new Projectile(px, py, pDx, pDy, final_damage, this.projectile_speed, 5, pPierce);
                       proj.isCrit = isCrit;
                       return proj;
                    }
                    const createExplosive = (px, py, pDx, pDy) => {
                       const proj = new ExplosiveProjectile(px, py, pDx, pDy, final_damage, this.projectile_speed, 7);
                       proj.isCrit = isCrit;
                       return proj;
                    }


                    if (this.attack_type === 'triple_piercing') {
                        const base_angle = Math.atan2(dy, dx);
                        for (let i = -1; i <= 1; i++) {
                            const angle = base_angle + (i * 15 * Math.PI / 180);
                            const p_dx = Math.cos(angle), p_dy = Math.sin(angle);
                            this.projectiles.push(createProjectile(this.x, this.y, p_dx, p_dy, this.pierce + 1));
                        }
                    } else if (this.attack_type === 'omni_shot') {
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * 45 * Math.PI / 180);
                            const p_dx = Math.cos(angle), p_dy = Math.sin(angle);
                            this.projectiles.push(createProjectile(this.x, this.y, p_dx, p_dy, this.pierce));
                        }
                    } else if (this.attack_type === 'explosive_shot') {
                        this.projectiles.push(createExplosive(this.x, this.y, dx / l, dy / l));
                    } else {
                        this.projectiles.push(createProjectile(this.x, this.y, dx / l, dy / l, this.pierce));
                    }
                }
                gain_xp(a) { this.xp += a * (this.xp_multiplier + this.xp_multiplier_talent_bonus); return this.xp >= this.xp_to_next_level; }
                level_up() { 
                    this.level++; 
                    this.xp -= this.xp_to_next_level; 
                    this.xp_to_next_level = Math.floor(this.xp_to_next_level * 1.5); 
                    this.hp = this.max_hp; 
                    this.mana = this.max_mana;
                    this.talentPoints++;
                }
                heal(a) { this.hp = Math.min(this.max_hp, this.hp + a); }
                cast_ability(sk, g, m) { if (sk in this.abilities) this.abilities[sk].activate(g, m); }
                learn_ability(ability_class) {
                    if (this.next_ability_slot <= 5) {
                        this.abilities[String(this.next_ability_slot)] = new ability_class(this);
                        this.next_ability_slot++;
                    }
                }
                take_damage(a) { this.hp -= a * (1 - this.damage_reduction); }
                draw(ctx, cx, cy) {
                    const drawX = this.x - cx - this.radius;
                    const drawY = this.y - cy - this.radius;

                    // Sombra do jogador
                    ctx.globalAlpha = 0.4;
                    ctx.drawImage(this.spriteSheet, this.animFrame * 32, 0, 32, 32, drawX + 3, drawY + 3, this.radius * 2, this.radius * 2);
                    ctx.globalAlpha = 1.0;

                    // Sprite principal do jogador
                    ctx.drawImage(this.spriteSheet, this.animFrame * 32, 0, 32, 32, drawX, drawY, this.radius * 2, this.radius * 2);

                    // Efeito de brilho mais intenso para o jogador
                    ctx.globalAlpha = 0.15;
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(drawX + 1, drawY + 1, this.radius * 2 - 2, 3);
                    ctx.fillRect(drawX + 1, drawY + 1, 3, this.radius * 2 - 2);
                    ctx.globalAlpha = 1.0;

                    // Efeito de aura sutil
                    ctx.globalAlpha = 0.05;
                    ctx.fillStyle = "#3296FF";
                    ctx.fillRect(drawX - 2, drawY - 2, this.radius * 2 + 4, this.radius * 2 + 4);
                    ctx.globalAlpha = 1.0;
                }
            }

            // ---------------- CLASSE PRINCIPAL DO JOGO ----------------
            class Game {
                constructor() {
                    this.state = "menu";
                    this.font_ui = "bold 14px 'Silkscreen'";
                    this.font_screen_title = "bold 36px 'Silkscreen'";
                    this.font_title = "bold 48px 'Silkscreen'";
                    this.font_card_title = "bold 16px 'Silkscreen'";
                    this.font_card_desc = "12px 'Silkscreen'";
                    this.font_damage = "bold 18px 'Silkscreen'";
                    this.font_menu = "bold 24px 'Silkscreen'";
                    this.font_button = "bold 20px 'Silkscreen'";
                    this.font_tutorial_title = "bold 22px 'Silkscreen'";
                    this.font_tutorial_text = "14px 'Silkscreen'";

                    this.vfx_effects = []; this.card_choices = []; this.card_rects = [];
                    
                    this.game_timer = 0; this.enemies_defeated = 0;
                    this.map = new Map(''); // A imagem do tileset é gerada no código, não precisa de nome
                    this.boss = null;
                    this.round = 1; this.enemies_killed_this_round = 0; this.round_kill_goal = 30;
                    this.round_start_timer = 0; this.round_start_text = "";
                    this.chests = []; this.show_chest_prompt = false; this.closest_chest = null;
                    this.statue = null; this.show_statue_prompt = false;
                    
                    this.activeInventoryTab = 'melhorias';
                    this.inventoryTabRects = [];
                    this.equipmentSlotRects = [];
                    this.inventoryItemRects = [];
                    this.skillTreeRects = [];

                    this.menu_buttons = []; this.pause_buttons = []; this.settings_buttons = [];
                    this.tutorial_scroll_y = 0; this.key_to_remap = null;
                    this.menu_particles = []; this.title_y_offset = 0; this.title_y_direction = 1;

                    this.soul_shop_items = [
                        { id: 'hp', text: 'Vigor Aumentado', description: '+10 Vida Máxima', base_cost: 50, level: 0, apply: p => { p.base_max_hp += 10; p.recalculateStats(); p.heal(10); } },
                        { id: 'dmg', text: 'Força Bruta', description: '+5% Dano', base_cost: 75, level: 0, apply: p => { p.base_damage_multiplier += 0.05; p.recalculateStats(); } },
                        { id: 'hp_regen', text: 'Bálsamo Natural', description: '+0.5 Regen. Vida', base_cost: 100, level: 0, apply: p => { p.base_hp_regen += 0.5; p.recalculateStats(); } },
                        { id: 'mana_regen', text: 'Clareza Mental', description: '+1 Regen. Mana', base_cost: 80, level: 0, apply: p => { p.base_mana_regen += 1; p.recalculateStats(); } },
                        { id: 'speed', text: 'Pés Ligeiros', description: '+5% Velocidade', base_cost: 60, level: 0, apply: p => { p.base_speed *= 1.05; p.recalculateStats(); } },
                    ];

                    this.setupMenu();
                }

                getSoulShopCost(item) {
                    return Math.floor(item.base_cost * Math.pow(1.25, item.level));
                }

                resetToMenu() {
                    this.player = null; this.state = 'menu';
                    this.soul_shop_items.forEach(item => item.level = 0);
                }

                setupMenu() {
                    this.menu_buttons = [
                        { text: 'Iniciar Jogo', y: SCREEN_HEIGHT / 2 + 40, action: () => this.startGame() },
                        { text: 'Tutorial', y: SCREEN_HEIGHT / 2 + 100, action: () => this.state = 'tutorial' },
                        { text: 'Configurações', y: SCREEN_HEIGHT / 2 + 160, action: () => this.state = 'settings' }
                    ];

                    this.pause_buttons = [
                        { text: 'Continuar', y: SCREEN_HEIGHT / 2, action: () => this.state = 'playing'},
                        { text: 'Voltar ao Menu', y: SCREEN_HEIGHT / 2 + 60, action: () => this.resetToMenu() }
                    ];
                    
                    for (let i = 0; i < 50; i++) {
                        this.menu_particles.push({
                            x: Math.random() * SCREEN_WIDTH, y: Math.random() * SCREEN_HEIGHT,
                            size: Math.random() * 2 + 1, speed: Math.random() * 10 + 5,
                            opacity: Math.random() * 0.5 + 0.2
                        });
                    }
                }
                startGame() {
                    const { data, playerStartPos, roomRectTiles, statuePos } = generateThroneRoomMap(MAP_WIDTH_TILES, MAP_HEIGHT_TILES);
                    this.map.loadMap(data, roomRectTiles);
                    this.player = new Player(playerStartPos.x, playerStartPos.y);
                    this.statue = new Statue(statuePos.x, statuePos.y);
                    this.enemies = []; this.enemy_projectiles = []; this.vfx_effects = []; this.chests = [];
                    this.enemy_spawn_timer = 2.5; this.game_timer = 0; this.enemies_defeated = 0;
                    this.boss = null; this.round = 1; this.enemies_killed_this_round = 0;
                    this.round_kill_goal = 20;
                    this.spawnChest();
                    this.enterAttackChoiceState();
                }
                all_enemies() { return this.enemies.concat(this.boss ? [this.boss] : []); }
                nextRound() {
                    this.round++;
                    this.enemies_killed_this_round = 0;
                    this.round_kill_goal = Math.floor(this.round_kill_goal * 1.15 + 5);
                    this.player.heal(this.player.max_hp * 0.10);
                    this.round_start_text = `Rodada ${this.round}`;
                    this.round_start_timer = 2.0;
                    this.spawnChest();
                    if (this.round % 10 === 0 && !this.boss) {
                        this.spawnBoss();
                    }
                }
                spawnChest() {
                    for (let i = 0; i < 50; i++) {
                        const x = (Math.floor(Math.random() * (this.map.room_rect_tiles.width - 2)) + this.map.room_rect_tiles.x + 1) * TILE_SIZE;
                        const y = (Math.floor(Math.random() * (this.map.room_rect_tiles.height - 2)) + this.map.room_rect_tiles.y + 1) * TILE_SIZE;
                        const tileX = Math.floor(x / TILE_SIZE); const tileY = Math.floor(y / TILE_SIZE);
                        if (this.player && Math.hypot(x - this.player.x, y - this.player.y) > 150) {
                           if (this.map.map_data[tileY][tileX] === 0) {
                                this.chests.push(new Chest(x, y)); return;
                           }
                        }
                    }
                }
                openChest(chest) {
                    const index = this.chests.indexOf(chest);
                    if (index > -1) this.chests.splice(index, 1);

                    const roll = Math.random() * 100;
                    if (roll <= 10) { 
                        this.enemies.push(new MimicEnemy(chest.x, chest.y));
                        this.vfx_effects.push(new RewardText(chest.x + TILE_SIZE/2, chest.y, "MÍMICO!", DAMAGE_COLOR));
                    } else if (roll <= 70) {
                        if (Math.random() < 0.40 && Object.keys(EQUIPMENT_ITEMS).length > 0) {
                            const itemKeys = Object.keys(EQUIPMENT_ITEMS);
                            const randomItemKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
                            const item = JSON.parse(JSON.stringify(EQUIPMENT_ITEMS[randomItemKey])); // Clone item
                            this.player.inventory.push(item);
                            this.vfx_effects.push(new RewardText(chest.x + TILE_SIZE/2, chest.y, `Item: ${item.name}`, GOLD_COLOR));
                        } else {
                            const RARE_REWARDS = [
                                { text: "+20 Vida Máx", color: HP_COLOR, effect: p => { p.base_max_hp += 20; p.recalculateStats(); p.heal(20); } },
                                { text: "+5 Dano Projétil", color: ATTACK_BORDER_COLOR, effect: p => {p.base_projectile_damage += 5; p.recalculateStats(); }},
                            ];
                            const reward = RARE_REWARDS[Math.floor(Math.random() * RARE_REWARDS.length)];
                            reward.effect(this.player);
                            this.vfx_effects.push(new RewardText(chest.x + TILE_SIZE/2, chest.y, reward.text, reward.color));
                        }
                    } else { 
                        this.vfx_effects.push(new RewardText(chest.x + TILE_SIZE/2, chest.y, "ITEM ÉPICO!", UNIQUE_BORDER_COLOR));
                        this.player.base_max_hp += 15; this.player.heal(15);
                        this.player.base_max_mana += 15;
                        this.player.base_projectile_damage += 3; this.player.base_damage_multiplier += 0.05;
                        this.player.base_speed *= 1.05;
                        this.player.recalculateStats();
                    }
                    this.show_chest_prompt = false; this.closest_chest = null;
                }
                spawnBoss() {
                    const x = (this.map.room_rect_tiles.x + this.map.room_rect_tiles.width / 2) * TILE_SIZE;
                    const y = (this.map.room_rect_tiles.y + 5) * TILE_SIZE;
                    this.boss = new BossEnemy(x, y, this.round);
                }
                spawnEnemy() {
                    const spawnCount = 1 + Math.floor(this.round / 4);
                    for(let i = 0; i < spawnCount; i++) {
                        const cam_rect = { x: this.player.x - SCREEN_WIDTH / 2, y: this.player.y - SCREEN_HEIGHT / 2, width: SCREEN_WIDTH, height: SCREEN_HEIGHT };
                        for (let j = 0; j < 20; j++) {
                            const x = (Math.floor(Math.random() * this.map.room_rect_tiles.width) + this.map.room_rect_tiles.x) * TILE_SIZE;
                            const y = (Math.floor(Math.random() * this.map.room_rect_tiles.height) + this.map.room_rect_tiles.y) * TILE_SIZE;
                            const enemy_rect = { x: x - 16, y: y - 16, width: 32, height: 32 };
                            const is_colliding_cam = !(enemy_rect.x > cam_rect.x + cam_rect.width || enemy_rect.x + enemy_rect.width < cam_rect.x || enemy_rect.y > cam_rect.y + cam_rect.height || enemy_rect.y + enemy_rect.height < cam_rect.y);
                            if (!is_colliding_cam && this.map.map_data[Math.floor(y/TILE_SIZE)][Math.floor(x/TILE_SIZE)] === 0) {
                                const roll = Math.random();
                                let enemy_to_spawn;
                                if (this.round > 5 && roll < 0.15) {
                                    enemy_to_spawn = new RangedEnemy(x, y, this.round);
                                } else if (this.round > 3 && roll < 0.35) {
                                    enemy_to_spawn = new BatEnemy(x, y, this.round);
                                } else if (this.round > 1 && roll < 0.6) {
                                    enemy_to_spawn = new SlimeEnemy(x, y, this.round);
                                } else {
                                    enemy_to_spawn = new BaseEnemy(x, y);
                                    enemy_to_spawn.max_hp *= (1 + this.round * 0.1); enemy_to_spawn.hp = enemy_to_spawn.max_hp;
                                    enemy_to_spawn.damage *= (1 + this.round * 0.1);
                                }
                                this.enemies.push(enemy_to_spawn);
                                break; 
                            }
                        }
                    }
                }
                enterAttackChoiceState() {
                    this.state = "attack_choice"; this.card_choices = STARTING_ATTACKS;
                    const card_w = 220, card_h = 340, spacing = 30;
                    const total_w = (card_w * this.card_choices.length) + (spacing * (this.card_choices.length - 1));
                    const start_x = (SCREEN_WIDTH - total_w) / 2, start_y = (SCREEN_HEIGHT - card_h) / 2;
                    this.card_rects = this.card_choices.map((_, i) => ({ x: start_x + i * (card_w + spacing), y: start_y, width: card_w, height: card_h }));
                }
                enterStartingChoiceState() {
                    this.state = "starting_choice"; this.card_choices = STARTING_BLESSINGS;
                    const card_w = 200, card_h = 320, spacing = 30;
                    const total_w = (card_w * this.card_choices.length) + (spacing * (this.card_choices.length - 1));
                    const start_x = (SCREEN_WIDTH - total_w) / 2, start_y = (SCREEN_HEIGHT - card_h) / 2;
                    this.card_rects = this.card_choices.map((_, i) => ({ x: start_x + i * (card_w + spacing), y: start_y, width: card_w, height: card_h }));
                }
                getCardChoices() {
                    let passives = [...PASSIVE_CARDS].sort(() => 0.5 - Math.random()).slice(0, 2);
                    const available_abilities = ABILITY_CARDS.filter(c => !Object.values(this.player.abilities).some(ab => ab instanceof c.ability_class));
                    if (available_abilities.length > 0 && this.player.next_ability_slot <= 5) {
                        return passives.concat(available_abilities[Math.floor(Math.random() * available_abilities.length)]);
                    }
                    return [...PASSIVE_CARDS].sort(() => 0.5 - Math.random()).slice(0, 3);
                }
                enterLevelUpState() {
                    this.state = "level_up"; this.player.level_up();
                    this.card_choices = this.getCardChoices().sort(() => 0.5 - Math.random());
                    const card_w = 200, card_h = 320, spacing = 30;
                    const total_w = (card_w * this.card_choices.length) + (spacing * (this.card_choices.length - 1));
                    const start_x = (SCREEN_WIDTH - total_w) / 2, start_y = (SCREEN_HEIGHT - card_h) / 2;
                    this.card_rects = this.card_choices.map((_, i) => ({ x: start_x + i * (card_w + spacing), y: start_y, width: card_w, height: card_h }));
                }
                enterSoulShopState() {
                    this.state = "soul_shop";
                }
                update(dt) {
                    if (this.state === "playing") {
                        if (this.round_start_timer > 0) this.round_start_timer -= dt;
                        this.game_timer += dt;
                        
                        this.enemy_spawn_timer -= dt;
                        if (this.enemy_spawn_timer <= 0) {
                            this.spawnEnemy();
                            this.enemy_spawn_timer = Math.max(0.1, 1.8 - (this.round * 0.075));
                        }
                        
                        const camx = this.player.x - SCREEN_WIDTH / 2; const camy = this.player.y - SCREEN_HEIGHT / 2;
                        const mwp = { x: mouse.x + camx, y: mouse.y + camy };
                        this.player.update(dt, mwp, this.map);
                        this.all_enemies().forEach(e => e.update(dt, this.player, this));
                        this.enemy_projectiles.forEach(p => p.update(dt));
                        this.enemy_projectiles = this.enemy_projectiles.filter(p => !p.isDead());
                        this.vfx_effects.forEach(vfx => vfx.update(dt));
                        this.vfx_effects = this.vfx_effects.filter(vfx => !vfx.isDead());
                        
                        this.closest_chest = null;
                        let min_dist_chest = 60; 
                        this.chests.forEach(chest => {
                            const dist = Math.hypot(this.player.x - (chest.x + chest.size/2), this.player.y - (chest.y + chest.size/2));
                            if (dist < min_dist_chest) {
                                min_dist_chest = dist;
                                this.closest_chest = chest;
                            }
                        });
                        this.show_chest_prompt = (this.closest_chest !== null);
                        
                        const dist_to_statue = Math.hypot(this.player.x - this.statue.x, this.player.y - this.statue.y);
                        this.show_statue_prompt = dist_to_statue < 60;

                        const targets = this.all_enemies();
                        for (let i = this.player.projectiles.length - 1; i >= 0; i--) {
                            const p = this.player.projectiles[i];
                            let collidedThisFrame = false;
                            for (const target of targets) {
                                if (!p.hit_enemies.has(target) && Math.hypot(p.x - target.x, p.y - target.y) < p.radius + target.radius) {
                                    p.hit_enemies.add(target);
                                    if (p instanceof ExplosiveProjectile) {
                                        this.vfx_effects.push(new ExplosionEffect(p.x, p.y, 80, p.damage, this));
                                        this.player.projectiles.splice(i, 1);
                                        collidedThisFrame = true; break;
                                    } else {
                                        target.takeDamage(p.damage, this, p.isCrit);
                                        p.pierce_count--;
                                        if (p.pierce_count <= 0) {
                                            this.player.projectiles.splice(i, 1);
                                            collidedThisFrame = true; break;
                                        }
                                    }
                                }
                            }
                            if(collidedThisFrame) continue;
                        }

                        const dead_enemies = this.all_enemies().filter(e => e.hp <= 0);
                        dead_enemies.forEach(e => {
                            if (this.player.gain_xp(e.xp_reward)) this.enterLevelUpState();
                            this.player.souls += e.soul_drop;
                            if (this.player.lifesteal_on_kill > 0) this.player.heal(this.player.lifesteal_on_kill);
                            
                            if (e === this.boss) {
                                this.boss = null;
                                this.vfx_effects.push(new RewardText(e.x, e.y, "CHEFE DERROTADO!", TITLE_COLOR));
                                this.enterLevelUpState();
                            } else {
                                const index = this.enemies.indexOf(e);
                                if (index > -1) {
                                    this.enemies.splice(index, 1);
                                    this.enemies_killed_this_round++;
                                }
                            }
                        });
                        
                        if (!this.boss && this.enemies_killed_this_round >= this.round_kill_goal) {
                           this.nextRound();
                        }

                        this.all_enemies().forEach(e => {
                             if (Math.hypot(e.x - this.player.x, e.y - this.player.y) < e.radius + this.player.radius) {
                                 this.player.take_damage(e.damage * dt);
                             }
                        });
                        if (this.player.hp <= 0) this.state = "game_over";
                    }
                }
                handleKeyDown(code) {
                    if (this.key_to_remap) {
                        if (code !== 'Escape') { 
                            keybinds[this.key_to_remap] = code;
                        }
                        this.key_to_remap = null;
                        return;
                    }

                    const keyAction = Object.keys(keybinds).find(key => keybinds[key] === code);
                    if (!keyAction) return;

                    if (keyAction === 'SHOW_INVENTORY') {
                        if (this.state === "playing") this.state = "inventory";
                        else if (this.state === "inventory") this.state = "playing";
                    } else if (keyAction === 'PAUSE') {
                         if (this.state === "playing") this.state = "paused";
                         else if (this.state === "paused") this.state = "playing";
                         else if (this.state === "soul_shop") this.state = "playing";
                         else if (this.state === "settings" || this.state === "tutorial") this.state = 'menu';
                    } else if ((this.state === "game_over") && code === 'KeyR') this.startGame();
                    else if (this.state === "menu" && code === 'Space') this.startGame();
                    else if (this.state === "playing" && keyAction === 'INTERACT') {
                        if (this.show_chest_prompt && this.closest_chest) {
                            this.openChest(this.closest_chest);
                        } else if (this.show_statue_prompt) {
                            this.enterSoulShopState();
                        }
                    } else if (this.state === "playing" && keyAction.startsWith('ABILITY')) {
                        const keyNum = keyAction.replace('ABILITY','');
                        const camx = this.player.x - SCREEN_WIDTH / 2; const camy = this.player.y - SCREEN_HEIGHT / 2;
                        const mwp = { x: mouse.x + camx, y: mouse.y + camy };
                        this.player.cast_ability(keyNum, this, mwp);
                    }
                }
                handleMouseClick() {
                    if (this.state === 'menu') {
                        this.menu_buttons.forEach(button => {
                            ctx.font = this.font_button;
                            const textWidth = ctx.measureText(button.text).width;
                            const rect = { x: SCREEN_WIDTH/2 - textWidth/2 - 20, y: button.y - 20, width: textWidth + 40, height: 40 };
                            if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                button.action();
                            }
                        });
                    } else if(this.state === 'paused') {
                        this.pause_buttons.forEach(button => {
                            ctx.font = this.font_button;
                            const textWidth = ctx.measureText(button.text).width;
                            const rect = { x: SCREEN_WIDTH/2 - textWidth/2 - 20, y: button.y - 20, width: textWidth + 40, height: 40 };
                            if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                button.action();
                            }
                        });
                    } else if(this.state === 'soul_shop') {
                        this.soul_shop_items.forEach((item, i) => {
                            const y = 120 + i * 65;
                            const rect = { x: 150, y: y, width: 500, height: 60 };
                            if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                const cost = this.getSoulShopCost(item);
                                if (this.player.souls >= cost) {
                                    this.player.souls -= cost;
                                    item.apply(this.player);
                                    item.level++;
                                }
                            }
                        });
                    } else if (this.state === 'inventory') {
                        this.inventoryTabRects.forEach(rect => {
                            if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                this.activeInventoryTab = rect.id;
                            }
                        });

                        if (this.activeInventoryTab === 'equipamentos') {
                            this.inventoryItemRects.forEach(rect => {
                                if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                    this.player.equipItem(rect.item);
                                }
                            });
                            this.equipmentSlotRects.forEach(rect => {
                                if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                    this.player.unequipItem(rect.type);
                                }
                            });
                        } else if (this.activeInventoryTab === 'talentos') {
                            this.skillTreeRects.forEach(rect => {
                                if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                    this.player.unlockTalent(rect.id);
                                }
                            });
                        }
                    } else if (this.state === 'settings') {
                         Object.keys(keybinds).forEach((action, i) => {
                            const y = 80 + i * 40;
                            const rect = { x: 100, y: y, width: 600, height: 35 };
                            if(mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                                this.key_to_remap = action;
                            }
                        });
                    } else if (this.state === "attack_choice") {
                        this.card_rects.forEach((r, i) => {
                            if (mouse.x > r.x && mouse.x < r.x + r.width && mouse.y > r.y && mouse.y < r.y + r.height) {
                                const chosen_card = this.card_choices[i];
                                this.player.attack_type = chosen_card.id;
                                this.player.collected_cards.push(chosen_card);
                                this.enterStartingChoiceState();
                            }
                        });
                    } else if (["level_up", "starting_choice"].includes(this.state)) {
                        this.card_rects.forEach((r, i) => {
                            if (mouse.x > r.x && mouse.x < r.x + r.width && mouse.y > r.y && mouse.y < r.y + r.height) {
                                const card = this.card_choices[i];
                                this.player.collected_cards.push(card);
                                if (card.type === 'passive') {
                                    card.apply(this.player);
                                }
                                else if (card.type === 'ability') this.player.learn_ability(card.ability_class);
                                this.player.recalculateStats();
                                this.state = "playing";
                            }
                        });
                    }
                }
                drawGameUI() {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                    ctx.fillRect(0, SCREEN_HEIGHT - 80, SCREEN_WIDTH, 80);
                    ctx.strokeStyle = "#444";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(0, SCREEN_HEIGHT - 80, SCREEN_WIDTH, 80);

                    const barWidth = 200, barHeight = 16;
                    drawBar(ctx, 20, SCREEN_HEIGHT - 60, barWidth, barHeight, this.player.hp, this.player.max_hp, HP_COLOR, `${Math.floor(this.player.hp)}/${this.player.max_hp}`);
                    drawBar(ctx, 20, SCREEN_HEIGHT - 35, barWidth, barHeight, this.player.mana, this.player.max_mana, MANA_COLOR, `${Math.floor(this.player.mana)}/${this.player.max_mana}`);

                    const icon_size = 40, num_slots = 5, slot_spacing = 10;
                    const total_width = num_slots * icon_size + (num_slots - 1) * slot_spacing;
                    const start_x = SCREEN_WIDTH / 2 - total_width / 2;
                    
                    for (let i = 1; i <= num_slots; i++) {
                        const key = String(i);
                        const slot_x = start_x + (i - 1) * (icon_size + slot_spacing);
                        const slot_rect = { x: slot_x, y: SCREEN_HEIGHT - 60, width: icon_size, height: icon_size };
                        
                        ctx.fillStyle = "#0A0C0F";
                        ctx.fillRect(slot_rect.x, slot_rect.y, slot_rect.width, slot_rect.height);
                        ctx.strokeStyle = "#50555A";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(slot_rect.x, slot_rect.y, slot_rect.width, slot_rect.height);
                        
                        if (key in this.player.abilities) {
                            const ability = this.player.abilities[key];
                            ability.drawIcon(ctx, slot_rect);
                            if (ability.cooldownTimer > 0) {
                                const cooldown_height = icon_size * (ability.cooldownTimer / (ability.cooldown * (1 - this.player.ability_cooldown_reduction)));
                                ctx.fillStyle = COOLDOWN_COLOR;
                                ctx.fillRect(slot_rect.x, slot_rect.y + icon_size - cooldown_height, icon_size, cooldown_height);
                                ctx.font = this.font_ui; ctx.fillStyle = WHITE; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                                ctx.fillText(ability.cooldownTimer.toFixed(1), slot_rect.x + icon_size / 2, slot_rect.y + icon_size / 2);
                            }
                        }
                    }

                    drawBar(ctx, 0, SCREEN_HEIGHT - 82, SCREEN_WIDTH, 4, this.player.xp, this.player.xp_to_next_level, XP_COLOR);

                    ctx.font = this.font_ui; ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                    const minutes = Math.floor(this.game_timer / 60);
                    const seconds = Math.floor(this.game_timer % 60);
                    ctx.fillStyle = WHITE; 
                    ctx.fillText(`Tempo: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, 10, 10);
                    ctx.fillText(`Rodada: ${this.round} | Nível: ${this.player.level}`, 10, 30);
                    ctx.fillStyle = SOUL_COLOR;
                    ctx.fillText(`Almas: ${this.player.souls}`, 10, 50);

                    if (this.boss) drawBar(ctx, SCREEN_WIDTH * 0.2, 20, SCREEN_WIDTH * 0.6, 25, this.boss.hp, this.boss.max_hp, "#960000", `CHEFE - Rodada ${this.round}`);
                }
                
                draw() {
                    ctx.fillStyle = DARK_BG;
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                    if (!this.player) { this.drawMenu(0); return; };

                    const camx = this.player.x - SCREEN_WIDTH / 2; const camy = this.player.y - SCREEN_HEIGHT / 2;
                    this.map.draw(ctx, camx, camy);
                    if(this.statue) this.statue.draw(ctx, camx, camy);
                    
                    // Desenha inimigos e baús antes do jogador
                    this.chests.forEach(c => c.draw(ctx, camx, camy));
                    this.all_enemies().forEach(e => e.draw(ctx, camx, camy));

                    // Desenha jogador e seus projéteis
                    this.player.draw(ctx, camx, camy);
                    this.player.projectiles.forEach(p => p.draw(ctx, camx, camy));
                    
                    // Desenha projéteis inimigos e efeitos por cima de tudo
                    this.enemy_projectiles.forEach(p => p.draw(ctx, camx, camy));
                    this.vfx_effects.forEach(vfx => vfx.draw(ctx, camx, camy));
                    
                    this.drawGameUI();
                    
                    let prompt_text = null;
                    if(this.show_statue_prompt) { prompt_text = `Pressione [${keybinds.INTERACT.replace('Key', '')}] para rezar`; } 
                    else if (this.show_chest_prompt) { prompt_text = `Pressione [${keybinds.INTERACT.replace('Key', '')}] para abrir`; }
                    
                    if (prompt_text) {
                        ctx.font = this.font_menu; ctx.textAlign = 'center';
                        const metrics = ctx.measureText(prompt_text);
                        const bg_rect = { x: SCREEN_WIDTH / 2 - metrics.width / 2 - 10, y: SCREEN_HEIGHT - 120, width: metrics.width + 20, height: 30 };
                        ctx.fillStyle = UI_BG_COLOR;
                        ctx.fillRect(bg_rect.x, bg_rect.y, bg_rect.width, bg_rect.height);
                        ctx.strokeStyle = WHITE;
                        ctx.strokeRect(bg_rect.x, bg_rect.y, bg_rect.width, bg_rect.height);
                        ctx.fillStyle = WHITE; ctx.textBaseline = 'middle';
                        ctx.fillText(prompt_text, SCREEN_WIDTH / 2, bg_rect.y + bg_rect.height / 2);
                    }
                    if (this.round_start_timer > 0) {
                        const age = 2.0 - this.round_start_timer; const p = age / 2.0;
                        let alpha = 1.0;
                        if (p < 0.2) alpha = p / 0.2;
                        else if (p > 0.8) alpha = (1.0 - p) / 0.2;
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
                        ctx.font = this.font_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(this.round_start_text, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 3);
                        ctx.restore();
                    }
                }
                drawCardScreen(title_text) {
                    ctx.fillStyle = DARK_BG;
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.font = this.font_screen_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(title_text, SCREEN_WIDTH / 2, 80);
                    
                    let hovered_idx = -1;
                    this.card_rects.forEach((r, i) => {
                         if (mouse.x > r.x && mouse.x < r.x + r.width && mouse.y > r.y && mouse.y < r.y + r.height) {
                             hovered_idx = i;
                         }
                    });

                    this.card_choices.forEach((card, i) => {
                        const rect = this.card_rects[i];
                        const is_hovered = (i === hovered_idx);
                        const border_size = is_hovered ? 4 : 2;
                        const cat_colors = {
                            "attack": [ATTACK_CARD_COLOR, ATTACK_BORDER_COLOR],
                            "support": [SUPPORT_CARD_COLOR, SUPPORT_BORDER_COLOR],
                            "ability": [ABILITY_CARD_COLOR, ABILITY_BORDER_COLOR]
                        };
                        let [bgColor, borderColor] = cat_colors[card.category] || [BAR_BG_COLOR, WHITE];
                        if (this.state === "starting_choice") { [bgColor, borderColor] = [UNIQUE_CARD_COLOR, UNIQUE_BORDER_COLOR]; }

                        ctx.fillStyle = bgColor;
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.strokeStyle = borderColor; ctx.lineWidth = border_size;
                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                        
                        drawTextWrapped(ctx, card.title, this.font_card_title, WHITE, { x: rect.x + 15, y: rect.y + 20, width: rect.width - 30 });
                        drawTextWrapped(ctx, card.description, this.font_card_desc, WHITE, { x: rect.x + 15, y: rect.y + 70, width: rect.width - 30 });
                        
                        if (card.get_details) {
                            const details_text = card.type === 'passive' ? card.get_details(this.player) : card.get_details(card.ability_class, this.player);
                            drawTextWrapped(ctx, details_text, this.font_card_desc, XP_COLOR, { x: rect.x + 15, y: rect.y + rect.height - 60, width: rect.width-30 });
                        }
                        if (this.state === "starting_choice") {
                            ctx.font = this.font_card_desc; ctx.fillStyle = UNIQUE_BORDER_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
                            ctx.fillText("Rank: Único", rect.x + rect.width / 2, rect.y + rect.height - 20);
                        }
                    });
                }
                drawSoulShopScreen() {
                    ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.font = this.font_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center';
                    ctx.fillText("Altar das Almas", SCREEN_WIDTH / 2, 60);
                    ctx.font = this.font_ui; ctx.fillStyle = SOUL_COLOR;
                    ctx.fillText(`Suas Almas: ${this.player.souls}`, SCREEN_WIDTH / 2, 100);
                    ctx.fillStyle = WHITE;
                    ctx.fillText(`Pressione [${keybinds.PAUSE.replace('Key', '')}] para sair`, SCREEN_WIDTH / 2, SCREEN_HEIGHT - 30);
                    
                    this.soul_shop_items.forEach((item, i) => {
                        const y = 120 + i * 65;
                        const cost = this.getSoulShopCost(item);
                        const can_afford = this.player.souls >= cost;
                        const rect = { x: 150, y: y, width: 500, height: 60 };
                        const isHovered = mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height;

                        ctx.fillStyle = isHovered ? '#444' : '#222';
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.strokeStyle = can_afford ? (isHovered ? WHITE : GOLD_COLOR) : '#555';
                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);

                        ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                        ctx.font = this.font_card_title; ctx.fillStyle = WHITE;
                        ctx.fillText(item.text, rect.x + 15, rect.y + 10);
                        
                        ctx.font = this.font_card_desc; ctx.fillStyle = '#ccc';
                        ctx.fillText(item.description, rect.x + 15, rect.y + 35);

                        ctx.textAlign = 'right'; ctx.font = this.font_ui;
                        ctx.fillStyle = can_afford ? SOUL_COLOR : '#777';
                        ctx.fillText(`Custo: ${cost}`, rect.x + rect.width - 15, rect.y + 10);
                        ctx.fillStyle = '#ccc';
                        ctx.fillText(`Nível: ${item.level}`, rect.x + rect.width - 15, rect.y + 35);
                    });
                }
                
                drawInventoryScreen() {
                    ctx.fillStyle = "rgba(40, 30, 20, 0.95)";
                    ctx.strokeStyle = "#8B4513";
                    ctx.lineWidth = 4;
                    const panelRect = { x: 50, y: 50, width: SCREEN_WIDTH - 100, height: SCREEN_HEIGHT - 100 };
                    ctx.fillRect(panelRect.x, panelRect.y, panelRect.width, panelRect.height);
                    ctx.strokeRect(panelRect.x, panelRect.y, panelRect.width, panelRect.height);

                    ctx.font = this.font_screen_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center';
                    ctx.fillText("Personagem", SCREEN_WIDTH / 2, 80);
                    ctx.font = this.font_ui; ctx.fillStyle = WHITE;
                    ctx.fillText(`Pressione [${keybinds.SHOW_INVENTORY.replace('Key', '')}] para voltar`, SCREEN_WIDTH / 2, SCREEN_HEIGHT - 70);

                    const tabs = [ { id: 'melhorias', name: 'Melhorias' }, { id: 'equipamentos', name: 'Equipamentos' }, { id: 'talentos', name: 'Talentos' } ];
                    const tabWidth = 150, tabHeight = 30;
                    this.inventoryTabRects = [];
                    tabs.forEach((tab, i) => {
                        const tabX = 60 + i * (tabWidth + 5);
                        const tabY = 95;
                        this.inventoryTabRects.push({x: tabX, y: tabY, width: tabWidth, height: tabHeight, id: tab.id});
                        const isActive = this.activeInventoryTab === tab.id;
                        
                        ctx.fillStyle = isActive ? "#6F4E37" : "#4A3525";
                        ctx.strokeStyle = isActive ? GOLD_COLOR : "#8B4513";
                        ctx.lineWidth = 2;
                        ctx.fillRect(tabX, tabY, tabWidth, tabHeight);
                        ctx.strokeRect(tabX, tabY, tabWidth, tabHeight);

                        ctx.font = this.font_ui; ctx.fillStyle = isActive ? WHITE : "#ccc";
                        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                        ctx.fillText(tab.name, tabX + tabWidth/2, tabY + tabHeight/2);
                    });
                    
                    if (this.activeInventoryTab === 'melhorias') { this.drawUpgradesTab(panelRect); } 
                    else if (this.activeInventoryTab === 'equipamentos') { this.drawEquipmentTab(panelRect); }
                    else if (this.activeInventoryTab === 'talentos') { this.drawSkillTreeTab(panelRect); }
                }

                drawUpgradesTab(panelRect) {
                    const attacks = this.player.collected_cards.filter(c => c.type === 'attack_choice');
                    const blessings = this.player.collected_cards.filter(c => STARTING_BLESSINGS.includes(c));
                    const abilities = this.player.collected_cards.filter(c => c.type === 'ability');
                    const passives = this.player.collected_cards.filter(c => c.type === 'passive' && !STARTING_BLESSINGS.includes(c));
                    const categories = [ { title: "Ataque Principal", cards: attacks }, { title: "Bênção Inicial", cards: blessings }, { title: "Habilidades", cards: abilities }, { title: "Melhorias Passivas", cards: passives } ];
                    let currentY = 150;
                    categories.forEach(cat => {
                        if (cat.cards.length > 0) {
                            ctx.font = this.font_tutorial_title; ctx.fillStyle = GOLD_COLOR;
                            ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                            ctx.fillText(cat.title, panelRect.x + 20, currentY);
                            currentY += 35;
                            cat.cards.forEach((card) => {
                                ctx.font = this.font_card_desc; ctx.fillStyle = WHITE;
                                ctx.fillText(`- ${card.title}: ${card.description}`, panelRect.x + 30, currentY);
                                currentY += 20;
                            });
                            currentY += 15;
                        }
                    });
                }
                
                drawEquipmentTab(panelRect) {
                    ctx.font = this.font_tutorial_title; ctx.fillStyle = GOLD_COLOR; ctx.textAlign = 'center';
                    ctx.fillText("Equipamentos", 220, 160);
                    ctx.fillText("Inventário", 550, 160);

                    const slotSize = 60;
                    const slots = [
                        {name: "Capacete", type: "helmet", x: 220, y: 220}, {name: "Peitoral", type: "chest", x: 220, y: 290},
                        {name: "Luvas", type: "gloves", x: 140, y: 290}, {name: "Botas", type: "boots", x: 300, y: 290},
                        {name: "Talismã", type: "talisman", x: 220, y: 360}
                    ];

                    this.equipmentSlotRects = [];
                    slots.forEach(slot => {
                        const rect = { x: slot.x - slotSize/2, y: slot.y - slotSize/2, width: slotSize, height: slotSize, type: slot.type };
                        this.equipmentSlotRects.push(rect);
                        ctx.strokeStyle = "#666"; ctx.fillStyle = "#222"; ctx.lineWidth = 2;
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                        
                        const item = this.player.equipment[slot.type];
                        if (item) {
                            drawTextWrapped(ctx, item.name, "bold 10px 'Silkscreen'", WHITE, {x: rect.x + 5, y: rect.y + 5, width: rect.width - 10});
                        } else {
                             ctx.font = this.font_ui; ctx.fillStyle = "#888";
                             ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                             ctx.fillText(slot.name, slot.x, slot.y);
                        }
                    });

                    this.inventoryItemRects = [];
                    const inventoryStartX = 450, inventoryStartY = 200;
                    const itemWidth = 200, itemHeight = 40;
                    this.player.inventory.forEach((item, i) => {
                        const rect = {x: inventoryStartX, y: inventoryStartY + i * (itemHeight + 5), width: itemWidth, height: itemHeight, item: item };
                        this.inventoryItemRects.push(rect);
                        const isHovered = mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height;
                        ctx.fillStyle = isHovered ? '#444' : '#222';
                        ctx.strokeStyle = GOLD_COLOR;
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.fillStyle = WHITE; ctx.font = this.font_ui;
                        ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                        ctx.fillText(item.name, rect.x + 10, rect.y + rect.height/2);
                    });
                }
                
                drawSkillTreeTab(panelRect) {
                    ctx.font = this.font_tutorial_title; ctx.fillStyle = GOLD_COLOR; ctx.textAlign = 'center';
                    ctx.fillText("Árvore de Talentos", SCREEN_WIDTH / 2, 160);
                    ctx.font = this.font_ui; ctx.fillStyle = WHITE; ctx.textAlign = 'left';
                    ctx.fillText(`Pontos: ${this.player.talentPoints}`, panelRect.x + 20, panelRect.y + 20);

                    this.skillTreeRects = [];
                    const nodeSize = 40;

                    for (const id in SKILL_TREE_NODES) {
                        const node = SKILL_TREE_NODES[id];
                        node.dependencies.forEach(depId => {
                            const depNode = SKILL_TREE_NODES[depId];
                            ctx.beginPath();
                            ctx.moveTo(depNode.x, depNode.y); ctx.lineTo(node.x, node.y);
                            ctx.strokeStyle = this.player.unlockedTalents.has(depId) ? GOLD_COLOR : '#555';
                            ctx.lineWidth = 2; ctx.stroke();
                        });
                    }

                    for (const id in SKILL_TREE_NODES) {
                        const node = SKILL_TREE_NODES[id];
                        const rect = { x: node.x - nodeSize/2, y: node.y - nodeSize/2, width: nodeSize, height: nodeSize, id: id };
                        this.skillTreeRects.push(rect);
                        const isUnlocked = this.player.unlockedTalents.has(id);
                        const canUnlock = node.dependencies.every(dep => this.player.unlockedTalents.has(dep)) && this.player.talentPoints >= node.cost;

                        ctx.beginPath();
                        ctx.arc(node.x, node.y, nodeSize / 2, 0, Math.PI * 2);
                        if (isUnlocked) { ctx.fillStyle = GOLD_COLOR; ctx.strokeStyle = WHITE; } 
                        else if (canUnlock) { ctx.fillStyle = '#444'; ctx.strokeStyle = GOLD_COLOR; }
                        else { ctx.fillStyle = '#222'; ctx.strokeStyle = '#555'; }
                        ctx.fill(); ctx.stroke();
                        
                        if (mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height) {
                            const tooltipWidth = 220, tooltipHeight = 90;
                            let tooltipX = mouse.x + 15;
                            let tooltipY = mouse.y;

                            if(tooltipX + tooltipWidth > SCREEN_WIDTH) tooltipX = mouse.x - tooltipWidth - 15;
                            if(tooltipY + tooltipHeight > SCREEN_HEIGHT) tooltipY = mouse.y - tooltipHeight;
                            
                            ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.strokeStyle = WHITE;
                            ctx.fillRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                            ctx.strokeRect(tooltipX, tooltipY, tooltipWidth, tooltipHeight);
                            
                            drawTextWrapped(ctx, node.name, "bold 14px 'Silkscreen'", GOLD_COLOR, {x: tooltipX + 10, y: tooltipY + 10, width: tooltipWidth - 20});
                            drawTextWrapped(ctx, node.description, "12px 'Silkscreen'", WHITE, {x: tooltipX + 10, y: tooltipY + 35, width: tooltipWidth - 20});
                            ctx.textAlign = 'left'; ctx.fillText(`Custo: ${node.cost}`, tooltipX + 10, tooltipY + 70);
                        }
                    }
                }

                drawFinalScreen(title, subtitle, buttons = []) {
                    ctx.fillStyle = "rgba(0,0,0,0.6)";
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.font = this.font_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(title, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 80);
                    ctx.font = this.font_menu; ctx.fillStyle = WHITE;
                    
                    if(subtitle) ctx.fillText(subtitle, SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 20);

                    if (buttons.length > 0) {
                        buttons.forEach(button => {
                             ctx.font = this.font_button;
                            const textWidth = ctx.measureText(button.text).width;
                            const rect = { x: SCREEN_WIDTH/2 - textWidth/2 - 20, y: button.y - 20, width: textWidth + 40, height: 40 };
                            const isHovered = mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height;
                            ctx.fillStyle = isHovered ? BAR_BG_COLOR : 'rgba(0,0,0,0.4)';
                            ctx.strokeStyle = isHovered ? WHITE : GOLD_COLOR;
                            ctx.lineWidth = 2;
                            ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                            ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                            ctx.fillStyle = isHovered ? WHITE : GOLD_COLOR;
                            ctx.fillText(button.text, SCREEN_WIDTH / 2, button.y);
                        });
                    } else {
                         ctx.fillText("Pressione [R] para jogar de novo", SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 + 60);
                    }
                }
                drawMenu(dt) {
                    ctx.fillStyle = DARK_BG;
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                    this.menu_particles.forEach(p => {
                        p.y -= p.speed * dt;
                        if (p.y < 0) { p.y = SCREEN_HEIGHT; p.x = Math.random() * SCREEN_WIDTH; }
                        ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
                    });
                    
                    this.title_y_offset += this.title_y_direction * dt * 5;
                    if (Math.abs(this.title_y_offset) > 5) { this.title_y_direction *= -1; }

                    ctx.font = this.font_title; ctx.fillStyle = TITLE_COLOR;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.shadowColor = GOLD_COLOR; ctx.shadowBlur = 15;
                    ctx.fillText("RPG SURVIVORS", SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2 - 100 + this.title_y_offset);
                    ctx.shadowBlur = 0;

                    this.menu_buttons.forEach(button => {
                        ctx.font = this.font_button;
                        const textWidth = ctx.measureText(button.text).width;
                        const rect = { x: SCREEN_WIDTH/2 - textWidth/2 - 20, y: button.y - 20, width: textWidth + 40, height: 40 };
                        const isHovered = mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height;
                        ctx.fillStyle = isHovered ? BAR_BG_COLOR : 'rgba(0,0,0,0.4)';
                        ctx.strokeStyle = isHovered ? WHITE : GOLD_COLOR;
                        ctx.lineWidth = 2;
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.fillStyle = isHovered ? WHITE : GOLD_COLOR;
                        ctx.fillText(button.text, SCREEN_WIDTH / 2, button.y);
                    });
                }
                drawSettingsScreen() {
                    ctx.fillStyle = DARK_BG;
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.font = this.font_screen_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center';
                    ctx.fillText("Configurações", SCREEN_WIDTH / 2, 40);
                    ctx.font = this.font_ui; ctx.fillStyle = WHITE;
                    ctx.fillText(`Pressione [${keybinds.PAUSE.replace('Key', '')}] para voltar`, SCREEN_WIDTH / 2, SCREEN_HEIGHT - 30);
                    Object.keys(keybinds).forEach((action, i) => {
                        const y = 80 + i * 40;
                        const rect = { x: 100, y: y, width: 600, height: 35 };
                        const isHovered = mouse.x > rect.x && mouse.x < rect.x + rect.width && mouse.y > rect.y && mouse.y < rect.y + rect.height;
                        ctx.fillStyle = isHovered ? '#333' : '#222';
                        ctx.strokeStyle = this.key_to_remap === action ? GOLD_COLOR : '#555';
                        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                        ctx.fillStyle = WHITE; ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                        ctx.fillText(keybindLabels[action], rect.x + 15, rect.y + rect.height/2);
                        ctx.textAlign = 'right';
                        const keyText = this.key_to_remap === action ? "???" : keybinds[action].replace('Key', '').replace('Digit', '');
                        ctx.fillText(keyText, rect.x + rect.width - 15, rect.y + rect.height/2);
                    });
                }
                drawTutorialScreen() {
                    ctx.fillStyle = DARK_BG;
                    ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                    ctx.font = this.font_screen_title; ctx.fillStyle = TITLE_COLOR; ctx.textAlign = 'center';
                    ctx.fillText("Como Jogar", SCREEN_WIDTH / 2, 40);
                    ctx.font = this.font_ui; ctx.fillStyle = WHITE;
                    ctx.fillText(`Pressione [${keybinds.PAUSE.replace('Key', '')}] para voltar`, SCREEN_WIDTH / 2, SCREEN_HEIGHT - 30);
                    const tutorial_text = [
                      {title: "Objetivo", text: "Sobreviva o máximo que puder contra hordas de inimigos. Derrote chefes a cada 10 rodadas para provar seu valor."},
                      {title: "Movimento", text: "Use as teclas para se mover. O personagem ataca automaticamente na direção do cursor do mouse."},
                      {title: "Recursos", text: "Sua barra vermelha é a Vida (HP) e a azul é a Mana. Se sua vida chegar a zero, o jogo acaba."},
                      {title: "Habilidades", text: "Use as teclas numéricas para ativar habilidades especiais que consomem Mana."},
                      {title: "Subindo de Nível", text: "Derrotar inimigos concede Experiência (XP). Suba de nível para escolher uma de três melhorias aleatórias e ganhar um Ponto de Talento."},
                      {title: "Almas e o Altar", text: "Inimigos deixam Almas. Interaja com a estátua para gastar Almas em melhorias que duram por toda a partida."},
                      {title: "Baús e Itens", text: "Abra baús para ganhar recompensas, como equipamentos que podem ser gerenciados no inventário (TAB). Cuidado com os mímicos!"},
                    ];
                    let y = 100;
                    tutorial_text.forEach(line => {
                        ctx.font = this.font_tutorial_title; ctx.fillStyle = GOLD_COLOR; ctx.textAlign = 'left';
                        ctx.fillText(line.title, 50, y); y += 25;
                        ctx.font = this.font_tutorial_text; ctx.fillStyle = WHITE;
                        drawTextWrapped(ctx, line.text, ctx.font, ctx.fillStyle, {x: 50, y: y, width: 700}); y += 70;
                    });
                }
                gameLoop(dt) {
                    if (this.state !== "paused" && this.state !== "inventory") {
                        if (this.state === 'playing') this.update(dt);
                    }
                    if (this.state === "playing") { this.draw(); } 
                    else if (this.state === "paused") { this.draw(); this.drawFinalScreen("PAUSADO", null, this.pause_buttons); } 
                    else if (this.state === "menu") { this.drawMenu(dt); } 
                    else if (this.state === 'settings') { this.drawSettingsScreen(); } 
                    else if (this.state === 'tutorial') { this.drawTutorialScreen(); } 
                    else if (this.state === 'soul_shop') { this.draw(); this.drawSoulShopScreen(); }
                    else if (this.state === "attack_choice") { this.draw(); this.drawCardScreen("Escolha seu Ataque Inicial"); } 
                    else if (this.state === "level_up") { this.draw(); this.drawCardScreen("Subiu de Nível!"); } 
                    else if (this.state === "starting_choice") { this.draw(); this.drawCardScreen("Escolha sua Bênção Inicial"); } 
                    else if (this.state === "inventory") { this.draw(); this.drawInventoryScreen(); } 
                    else if (this.state === "game_over") { this.draw(); this.drawFinalScreen("FIM DE JOGO", `Você sobreviveu por ${Math.floor(this.game_timer)} segundos`); }
                    if (mouse.clicked) { this.handleMouseClick(); mouse.clicked = false; }
                }
            }

            // --- INICIALIZAÇÃO DO JOGO ---
            game = new Game();
            let lastTime = 0;
            function run(timestamp) {
                const dt = (timestamp - lastTime) / 1000;
                lastTime = timestamp;
                if (dt < 1) { game.gameLoop(dt || 0); }
                requestAnimationFrame(run);
            }
            requestAnimationFrame(run);
        };
    </script>
</body>
</html>